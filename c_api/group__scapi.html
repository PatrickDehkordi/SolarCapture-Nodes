<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SolarCapture C Bindings: SolarCapture API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="sf_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SolarCapture C Bindings
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SolarCapture API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:args_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="args_8h.html">args.h</a></td></tr>
<tr class="memdesc:args_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__scapi.html#structsc__arg" title="Representation of an argument. Used by node init functions. ">sc_arg</a>: An argument to a node's initialisation function. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:attr_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="attr_8h.html">attr.h</a></td></tr>
<tr class="memdesc:attr_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__scapi.html#structsc__attr" title="Attribute object. ">sc_attr</a>: Control optional behaviours and tunables. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:declare__types_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="declare__types_8h.html">declare_types.h</a></td></tr>
<tr class="memdesc:declare__types_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This header is used to generate C type definitions and corresponding runtime type information for data structures that are shared by SolarCapture with other processes. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dlist_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html">dlist.h</a></td></tr>
<tr class="memdesc:dlist_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__scapi.html#structsc__dlist" title="Doubly linked list pointers. ">sc_dlist</a>: A doubly-linked list. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:event_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html">event.h</a></td></tr>
<tr class="memdesc:event_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__scapi.html#structsc__callback" title="A callback object. ">sc_callback</a>: Interface for event notification. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ext__node_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ext__node_8h.html">ext_node.h</a></td></tr>
<tr class="memdesc:ext__node_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for writing custom nodes. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ext__packet_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ext__packet_8h.html">ext_packet.h</a></td></tr>
<tr class="memdesc:ext__packet_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__scapi.html#structsc__packet" title="Representation of a packet. ">sc_packet</a>: The representation of a packet or other data. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ext__packet__list_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ext__packet__list_8h.html">ext_packet_list.h</a></td></tr>
<tr class="memdesc:ext__packet__list_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__scapi.html#structsc__packet__list" title="A list of packets or packet buffers. ">sc_packet_list</a>: A list of packets. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:iovec_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iovec_8h.html">iovec.h</a></td></tr>
<tr class="memdesc:iovec_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a>: Supports iterating over a 'struct iovec'. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mailbox_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mailbox_8h.html">mailbox.h</a></td></tr>
<tr class="memdesc:mailbox_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">sc_mailbox: A means to pass packets from one thread to another. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:misc_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="misc_8h.html">misc.h</a></td></tr>
<tr class="memdesc:misc_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Miscellaneous utility functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:node_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html">node.h</a></td></tr>
<tr class="memdesc:node_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__scapi.html#structsc__node" title="Description of a node. ">sc_node</a>: An object that processes packets. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:object_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="object_8h.html">object.h</a></td></tr>
<tr class="memdesc:object_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>: Opaque object interface. Use this to pass all types of data that are not ints, doubles or char arrays (see <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a>, <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a81f048052c4a067d1d53144de606cf2b">SC_PARAM_DBL</a> and <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> respectively for these). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pkt__pool_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pkt__pool_8h.html">pkt_pool.h</a></td></tr>
<tr class="memdesc:pkt__pool_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">sc_pool: A pool of packet buffers. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:predicate_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="predicate_8h.html">predicate.h</a></td></tr>
<tr class="memdesc:predicate_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__scapi.html#structsc__pkt__predicate" title="A packet predicate object. ">sc_pkt_predicate</a>: Interface for testing properties of packets. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:session_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="session_8h.html">session.h</a></td></tr>
<tr class="memdesc:session_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">sc_session: A set of threads and other objects. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:stream_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream_8h.html">stream.h</a></td></tr>
<tr class="memdesc:stream_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This header file defines sc_stream objects for directing packets to a <a class="el" href="group__scapi.html#structsc__vi" title="A VI object. ">sc_vi</a> instance. A packet must match all the stream criteria for it to be directed by the stream to an <a class="el" href="group__scapi.html#structsc__vi" title="A VI object. ">sc_vi</a> instance. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:thread_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html">thread.h</a></td></tr>
<tr class="memdesc:thread_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">sc_thread: Representation of a thread in SolarCapture. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:time_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="time_8h.html">time.h</a></td></tr>
<tr class="memdesc:time_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for managing time. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vi_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vi_8h.html">vi.h</a></td></tr>
<tr class="memdesc:vi_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__scapi.html#structsc__vi" title="A VI object. ">sc_vi</a>: Supports receiving packets from the network. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structsc__arg"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__arg">sc_arg</a></td></tr>
<tr class="memdesc:structsc__arg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an argument. Used by node init functions.  <a href="group__scapi.html#structsc__arg">More...</a><br/></td></tr>
<tr class="separator:structsc__arg"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionsc__arg_8val"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#unionsc__arg_8val">sc_arg.val</a></td></tr>
<tr class="separator:unionsc__arg_8val"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__dlist"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a></td></tr>
<tr class="memdesc:structsc__dlist"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doubly linked list pointers.  <a href="group__scapi.html#structsc__dlist">More...</a><br/></td></tr>
<tr class="separator:structsc__dlist"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__callback"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__callback">sc_callback</a></td></tr>
<tr class="memdesc:structsc__callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback object.  <a href="group__scapi.html#structsc__callback">More...</a><br/></td></tr>
<tr class="separator:structsc__callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__node"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__node">sc_node</a></td></tr>
<tr class="memdesc:structsc__node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of a node.  <a href="group__scapi.html#structsc__node">More...</a><br/></td></tr>
<tr class="separator:structsc__node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__node__link"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a></td></tr>
<tr class="memdesc:structsc__node__link"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of a link the node has.  <a href="group__scapi.html#structsc__node__link">More...</a><br/></td></tr>
<tr class="separator:structsc__node__link"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__node__factory"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__node__factory">sc_node_factory</a></td></tr>
<tr class="memdesc:structsc__node__factory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold information about how to create an instance of this node.  <a href="group__scapi.html#structsc__node__factory">More...</a><br/></td></tr>
<tr class="separator:structsc__node__factory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__node__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__node__type">sc_node_type</a></td></tr>
<tr class="memdesc:structsc__node__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a type of node.  <a href="group__scapi.html#structsc__node__type">More...</a><br/></td></tr>
<tr class="separator:structsc__node__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__packet"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__packet">sc_packet</a></td></tr>
<tr class="memdesc:structsc__packet"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a packet.  <a href="group__scapi.html#structsc__packet">More...</a><br/></td></tr>
<tr class="separator:structsc__packet"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__packet__list"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a></td></tr>
<tr class="memdesc:structsc__packet__list"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of packets or packet buffers.  <a href="group__scapi.html#structsc__packet__list">More...</a><br/></td></tr>
<tr class="separator:structsc__packet__list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__iovec__ptr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a></td></tr>
<tr class="separator:structsc__iovec__ptr"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__pkt__predicate"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__pkt__predicate">sc_pkt_predicate</a></td></tr>
<tr class="memdesc:structsc__pkt__predicate"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet predicate object.  <a href="group__scapi.html#structsc__pkt__predicate">More...</a><br/></td></tr>
<tr class="separator:structsc__pkt__predicate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__session__error"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__session__error">sc_session_error</a></td></tr>
<tr class="memdesc:structsc__session__error"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SolarCapture session error object returned by <a class="el" href="group__scapi.html#gaa2ed816358bceda7232241aec4a56fc2" title="Returns an error from a SolarCapture session. ">sc_session_error_get</a>.  <a href="group__scapi.html#structsc__session__error">More...</a><br/></td></tr>
<tr class="separator:structsc__session__error"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__attr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__attr">sc_attr</a></td></tr>
<tr class="memdesc:structsc__attr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute object.  <a href="group__scapi.html#structsc__attr">More...</a><br/></td></tr>
<tr class="separator:structsc__attr"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__object"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__object">sc_object</a></td></tr>
<tr class="memdesc:structsc__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a>, <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a81f048052c4a067d1d53144de606cf2b">SC_PARAM_DBL</a> and <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> respectively for these) to nodes.  <a href="group__scapi.html#structsc__object">More...</a><br/></td></tr>
<tr class="separator:structsc__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__vi"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#structsc__vi">sc_vi</a></td></tr>
<tr class="memdesc:structsc__vi"><td class="mdescLeft">&#160;</td><td class="mdescRight">A VI object.  <a href="group__scapi.html#structsc__vi">More...</a><br/></td></tr>
<tr class="separator:structsc__vi"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1db82ea8e9e2b3e0c226e4da5911cab7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga1db82ea8e9e2b3e0c226e4da5911cab7">SC_ARG_INT</a>(_name, _val)&#160;&#160;&#160;{ .name = _name, .type = <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a>, .val.i = _val }</td></tr>
<tr class="separator:ga1db82ea8e9e2b3e0c226e4da5911cab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3d8599771d57cf1700f84faf6ab21cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaa3d8599771d57cf1700f84faf6ab21cb">SC_ARG_STR</a>(_name, _val)&#160;&#160;&#160;{ .name = _name, .type = <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a>, .val.str = _val }</td></tr>
<tr class="separator:gaa3d8599771d57cf1700f84faf6ab21cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2971ec30636efc68f77de53ded68aa40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga2971ec30636efc68f77de53ded68aa40">SC_ARG_OBJ</a>(_name, _val)&#160;&#160;&#160;{ .name = _name, .type = <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a582ef31fdf6cc8bdbd1153cb2afc560b">SC_PARAM_OBJ</a>, .val.obj = _val }</td></tr>
<tr class="separator:ga2971ec30636efc68f77de53ded68aa40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga576987c4c7e5cfff5565568168ccf32b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga576987c4c7e5cfff5565568168ccf32b">SC_ARG_DBL</a>(_name, _val)&#160;&#160;&#160;{ .name = _name, .type = <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a81f048052c4a067d1d53144de606cf2b">SC_PARAM_DBL</a>, .val.dbl = _val }</td></tr>
<tr class="separator:ga576987c4c7e5cfff5565568168ccf32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga357de7af8618e5b26ed52e01c0158508"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga357de7af8618e5b26ed52e01c0158508">ST_CONSTANT</a>(name, val)&#160;&#160;&#160;enum { name = val };a</td></tr>
<tr class="memdesc:ga357de7af8618e5b26ed52e01c0158508"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant value in the template definition.  <a href="#ga357de7af8618e5b26ed52e01c0158508">More...</a><br/></td></tr>
<tr class="separator:ga357de7af8618e5b26ed52e01c0158508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140c90f6225c3044aa11493432cde1e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga140c90f6225c3044aa11493432cde1e4">ST_STRUCT</a>(name)&#160;&#160;&#160;struct name {</td></tr>
<tr class="memdesc:ga140c90f6225c3044aa11493432cde1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of the template definition.  <a href="#ga140c90f6225c3044aa11493432cde1e4">More...</a><br/></td></tr>
<tr class="separator:ga140c90f6225c3044aa11493432cde1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga558f37e5def5f1639a6780d3b6d089ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga558f37e5def5f1639a6780d3b6d089ea">ST_FIELD_STR</a>(name, len, kind)&#160;&#160;&#160;char name[len];</td></tr>
<tr class="memdesc:ga558f37e5def5f1639a6780d3b6d089ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string field in the template definition.  <a href="#ga558f37e5def5f1639a6780d3b6d089ea">More...</a><br/></td></tr>
<tr class="separator:ga558f37e5def5f1639a6780d3b6d089ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fefab940214b246feaafded5776dc63"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga5fefab940214b246feaafded5776dc63">ST_FIELD</a>(type, name, kind)&#160;&#160;&#160;type name;</td></tr>
<tr class="memdesc:ga5fefab940214b246feaafded5776dc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C basic type field in the template definition.  <a href="#ga5fefab940214b246feaafded5776dc63">More...</a><br/></td></tr>
<tr class="separator:ga5fefab940214b246feaafded5776dc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47d89277e9453a755af2933d8e1ed34e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga47d89277e9453a755af2933d8e1ed34e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga47d89277e9453a755af2933d8e1ed34e">ST_STRUCT_END</a>&#160;&#160;&#160;};</td></tr>
<tr class="memdesc:ga47d89277e9453a755af2933d8e1ed34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of the template definition. <br/></td></tr>
<tr class="separator:ga47d89277e9453a755af2933d8e1ed34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3152057b96aae8e524716cf30bc166c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga3152057b96aae8e524716cf30bc166c1">SC_CONTAINER</a>(c_type, mbr_name, p_mbr)&#160;&#160;&#160;( (c_type*) ((char*)(p_mbr) - <a class="el" href="group__scapi.html#ga082426dca3734e1a84e51424a8a0a012">SC_MEMBER_OFFSET</a>(c_type, mbr_name)) )</td></tr>
<tr class="memdesc:ga3152057b96aae8e524716cf30bc166c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a pointer to the outer container of a given <a class="el" href="group__scapi.html#structsc__dlist" title="Doubly linked list pointers. ">sc_dlist</a> pointer.  <a href="#ga3152057b96aae8e524716cf30bc166c1">More...</a><br/></td></tr>
<tr class="separator:ga3152057b96aae8e524716cf30bc166c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8034044fe316eae0804c49db256df481"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga8034044fe316eae0804c49db256df481">SC_DLIST_FOR_EACH_OBJ</a>(list, iter, mbr)</td></tr>
<tr class="memdesc:ga8034044fe316eae0804c49db256df481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a for statement that loops over each container item in the list. It is not safe to modify the list using this macro, if list modifications are required see <a class="el" href="group__scapi.html#gaa2e795d924234a1e1415d55021b82ad8" title="Create a for statement that loops over each container item in the list which can be safely be modifie...">SC_DLIST_FOR_EACH_OBJ_SAFE</a>.  <a href="#ga8034044fe316eae0804c49db256df481">More...</a><br/></td></tr>
<tr class="separator:ga8034044fe316eae0804c49db256df481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e795d924234a1e1415d55021b82ad8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaa2e795d924234a1e1415d55021b82ad8">SC_DLIST_FOR_EACH_OBJ_SAFE</a>(list, iter, next_entry, mbr)</td></tr>
<tr class="memdesc:gaa2e795d924234a1e1415d55021b82ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a for statement that loops over each container item in the list which can be safely be modified during traversal.  <a href="#gaa2e795d924234a1e1415d55021b82ad8">More...</a><br/></td></tr>
<tr class="separator:gaa2e795d924234a1e1415d55021b82ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac01197f593310d5792375fd1bf10ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gafac01197f593310d5792375fd1bf10ab">sc_node_set_error</a>(node, errno_code,...)</td></tr>
<tr class="memdesc:gafac01197f593310d5792375fd1bf10ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set error from within the implementation of a node.  <a href="#gafac01197f593310d5792375fd1bf10ab">More...</a><br/></td></tr>
<tr class="separator:gafac01197f593310d5792375fd1bf10ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ea22a86b4ebe75ab2d4c0ed555c551"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gad8ea22a86b4ebe75ab2d4c0ed555c551">sc_node_fwd_error</a>(node, rc)&#160;&#160;&#160;__sc_node_fwd_error((node), __FILE__, __LINE__, __func__, (rc))</td></tr>
<tr class="memdesc:gad8ea22a86b4ebe75ab2d4c0ed555c551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward error from a failed sc call.  <a href="#gad8ea22a86b4ebe75ab2d4c0ed555c551">More...</a><br/></td></tr>
<tr class="separator:gad8ea22a86b4ebe75ab2d4c0ed555c551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga082426dca3734e1a84e51424a8a0a012"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga082426dca3734e1a84e51424a8a0a012">SC_MEMBER_OFFSET</a>(c_type, mbr_name)&#160;&#160;&#160;((uint32_t) (uintptr_t)(&amp;((c_type*)0)-&gt;mbr_name))</td></tr>
<tr class="memdesc:ga082426dca3734e1a84e51424a8a0a012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate memory offset of a field within a struct.  <a href="#ga082426dca3734e1a84e51424a8a0a012">More...</a><br/></td></tr>
<tr class="separator:ga082426dca3734e1a84e51424a8a0a012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e99f50e4d3eaccea8700ab02f56a581"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga8e99f50e4d3eaccea8700ab02f56a581">SC_MEMBER_SIZE</a>(c_type, mbr_name)&#160;&#160;&#160;(sizeof(((c_type*)0)-&gt;mbr_name))</td></tr>
<tr class="memdesc:ga8e99f50e4d3eaccea8700ab02f56a581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size of a field within a struct.  <a href="#ga8e99f50e4d3eaccea8700ab02f56a581">More...</a><br/></td></tr>
<tr class="separator:ga8e99f50e4d3eaccea8700ab02f56a581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a3adef0054f272898fd778be0de1d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf6a3adef0054f272898fd778be0de1d4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaf6a3adef0054f272898fd778be0de1d4">SC_FRAME_LEN_LARGE</a>&#160;&#160;&#160;UINT16_MAX</td></tr>
<tr class="memdesc:gaf6a3adef0054f272898fd778be0de1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct <a class="el" href="group__scapi.html#aae5c3741cf9dc13a215856b6186a5273">sc_packet.frame_len</a> holds this special value to indicate that the frame is "large". (Meaning it would overflow <a class="el" href="group__scapi.html#aae5c3741cf9dc13a215856b6186a5273">sc_packet.frame_len</a>). <br/></td></tr>
<tr class="separator:gaf6a3adef0054f272898fd778be0de1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b33e1568c9c145bc14b8850e88d927a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b33e1568c9c145bc14b8850e88d927a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga3b33e1568c9c145bc14b8850e88d927a">SC_CSUM_ERROR</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="memdesc:ga3b33e1568c9c145bc14b8850e88d927a"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct <a class="el" href="group__scapi.html#a0764f4fab658f994793f89fa51742937">sc_packet.flags</a> will have this set if the packet has a checksum error <br/></td></tr>
<tr class="separator:ga3b33e1568c9c145bc14b8850e88d927a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04492aa794035aae81ce978eaccf998f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga04492aa794035aae81ce978eaccf998f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga04492aa794035aae81ce978eaccf998f">SC_CRC_ERROR</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="memdesc:ga04492aa794035aae81ce978eaccf998f"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct <a class="el" href="group__scapi.html#a0764f4fab658f994793f89fa51742937">sc_packet.flags</a> will have this set if the packet has a crc error <br/></td></tr>
<tr class="separator:ga04492aa794035aae81ce978eaccf998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ad3695c1a564a497115049c0a3381f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6ad3695c1a564a497115049c0a3381f7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga6ad3695c1a564a497115049c0a3381f7">SC_TRUNCATED</a>&#160;&#160;&#160;(1 &lt;&lt; 2)</td></tr>
<tr class="memdesc:ga6ad3695c1a564a497115049c0a3381f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct <a class="el" href="group__scapi.html#a0764f4fab658f994793f89fa51742937">sc_packet.flags</a> will have this set if the packet has been truncated <br/></td></tr>
<tr class="separator:ga6ad3695c1a564a497115049c0a3381f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e3a90255417683eb917a1e41f60ea8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga98e3a90255417683eb917a1e41f60ea8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga98e3a90255417683eb917a1e41f60ea8">SC_MCAST_MISMATCH</a>&#160;&#160;&#160;(1 &lt;&lt; 3)</td></tr>
<tr class="memdesc:ga98e3a90255417683eb917a1e41f60ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct <a class="el" href="group__scapi.html#a0764f4fab658f994793f89fa51742937">sc_packet.flags</a> will have this set if the packet is for a multicast group the host hasn't joined <br/></td></tr>
<tr class="separator:ga98e3a90255417683eb917a1e41f60ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad844c9b814f048aaa4961fda2c3a61c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad844c9b814f048aaa4961fda2c3a61c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gad844c9b814f048aaa4961fda2c3a61c2">SC_UCAST_MISMATCH</a>&#160;&#160;&#160;(1 &lt;&lt; 4)</td></tr>
<tr class="memdesc:gad844c9b814f048aaa4961fda2c3a61c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct <a class="el" href="group__scapi.html#a0764f4fab658f994793f89fa51742937">sc_packet.flags</a> will have this set if the packet is for a unicast address not matching the host's <br/></td></tr>
<tr class="separator:gad844c9b814f048aaa4961fda2c3a61c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8cf1e664fe251b17c7bfb3aaa89548ff"><td class="memItemLeft" align="right" valign="top">typedef void(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga8cf1e664fe251b17c7bfb3aaa89548ff">sc_callback_handler_fn</a> )(struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *, void *event_info)</td></tr>
<tr class="memdesc:ga8cf1e664fe251b17c7bfb3aaa89548ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback handler function.  <a href="#ga8cf1e664fe251b17c7bfb3aaa89548ff">More...</a><br/></td></tr>
<tr class="separator:ga8cf1e664fe251b17c7bfb3aaa89548ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec792135358df254bea89bb9dd6a2a09"><td class="memItemLeft" align="right" valign="top">typedef int(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaec792135358df254bea89bb9dd6a2a09">sc_node_init_fn</a> )(struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, const struct <a class="el" href="group__scapi.html#structsc__node__factory">sc_node_factory</a> *)</td></tr>
<tr class="memdesc:gaec792135358df254bea89bb9dd6a2a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of function to initialise a node.  <a href="#gaec792135358df254bea89bb9dd6a2a09">More...</a><br/></td></tr>
<tr class="separator:gaec792135358df254bea89bb9dd6a2a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be5c52459c32aba638861f7d775b223"><td class="memItemLeft" align="right" valign="top">typedef int(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga4be5c52459c32aba638861f7d775b223">sc_node_prep_fn</a> )(struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a> *const *links, int n_links)</td></tr>
<tr class="memdesc:ga4be5c52459c32aba638861f7d775b223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of nt_prep_fn function.  <a href="#ga4be5c52459c32aba638861f7d775b223">More...</a><br/></td></tr>
<tr class="separator:ga4be5c52459c32aba638861f7d775b223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30a15ad23a4ff1bc74d489e61a187ec9"><td class="memItemLeft" align="right" valign="top">typedef void(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga30a15ad23a4ff1bc74d489e61a187ec9">sc_node_pkts_fn</a> )(struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *packet_list)</td></tr>
<tr class="memdesc:ga30a15ad23a4ff1bc74d489e61a187ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of nt_pkts_fn function.  <a href="#ga30a15ad23a4ff1bc74d489e61a187ec9">More...</a><br/></td></tr>
<tr class="separator:ga30a15ad23a4ff1bc74d489e61a187ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1746848cc14ace3891999a360bc8d48a"><td class="memItemLeft" align="right" valign="top">typedef int(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga1746848cc14ace3891999a360bc8d48a">sc_node_add_link_fn</a> )(struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *from_node, const char *link_name, struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *to_node, const char *to_name_opt)</td></tr>
<tr class="memdesc:ga1746848cc14ace3891999a360bc8d48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of nt_add_link_fn function.  <a href="#ga1746848cc14ace3891999a360bc8d48a">More...</a><br/></td></tr>
<tr class="separator:ga1746848cc14ace3891999a360bc8d48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad856a763cba38bb2c58a8fd7ec5a866c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gad856a763cba38bb2c58a8fd7ec5a866c">sc_node_select_subnode_fn</a> )(struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *name, char **new_name_out)</td></tr>
<tr class="memdesc:gad856a763cba38bb2c58a8fd7ec5a866c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of nt_select_subnode_fn function.  <a href="#gad856a763cba38bb2c58a8fd7ec5a866c">More...</a><br/></td></tr>
<tr class="separator:gad856a763cba38bb2c58a8fd7ec5a866c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcdef5088baa04ac5bf37fcf5a90cd0e"><td class="memItemLeft" align="right" valign="top">typedef void(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gadcdef5088baa04ac5bf37fcf5a90cd0e">sc_node_end_of_stream_fn</a> )(struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node)</td></tr>
<tr class="memdesc:gadcdef5088baa04ac5bf37fcf5a90cd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature of nt_end_of_stream_fn function.  <a href="#gadcdef5088baa04ac5bf37fcf5a90cd0e">More...</a><br/></td></tr>
<tr class="separator:gadcdef5088baa04ac5bf37fcf5a90cd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f3af5b9fd87f66fd0031a5fe63d106"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa3f3af5b9fd87f66fd0031a5fe63d106"></a>
typedef int(&#160;</td><td class="memItemRight" valign="bottom"><b>sc_pkt_predicate_test_fn</b> )(struct <a class="el" href="group__scapi.html#structsc__pkt__predicate">sc_pkt_predicate</a> *, struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *)</td></tr>
<tr class="separator:gaa3f3af5b9fd87f66fd0031a5fe63d106"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga0fbf06fdd6b6fea5987db9f1925a6003"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga0fbf06fdd6b6fea5987db9f1925a6003">sc_param_type</a> { <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a>, 
<a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a>, 
<a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a582ef31fdf6cc8bdbd1153cb2afc560b">SC_PARAM_OBJ</a>, 
<a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a81f048052c4a067d1d53144de606cf2b">SC_PARAM_DBL</a>
 }</td></tr>
<tr class="memdesc:ga0fbf06fdd6b6fea5987db9f1925a6003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible parameter types that can be used for arguments in a node's init function.  <a href="group__scapi.html#ga0fbf06fdd6b6fea5987db9f1925a6003">More...</a><br/></td></tr>
<tr class="separator:ga0fbf06fdd6b6fea5987db9f1925a6003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dbec837a1592a9f6a4bc649ea583f0d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga7dbec837a1592a9f6a4bc649ea583f0d">sc_object_type</a> { <b>SC_OBJ_ANY</b>, 
<a class="el" href="group__scapi.html#gga7dbec837a1592a9f6a4bc649ea583f0da6cc791f350dc8201235237b69a7c428e">SC_OBJ_OPAQUE</a>, 
<a class="el" href="group__scapi.html#gga7dbec837a1592a9f6a4bc649ea583f0dae140bed569231d8aa0df5929f388cb03">SC_OBJ_PKT_PREDICATE</a>
 }</td></tr>
<tr class="memdesc:ga7dbec837a1592a9f6a4bc649ea583f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of data the <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a> contains.  <a href="group__scapi.html#ga7dbec837a1592a9f6a4bc649ea583f0d">More...</a><br/></td></tr>
<tr class="separator:ga7dbec837a1592a9f6a4bc649ea583f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2fec54c32ef2624a3b888b0808b1d140"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga2fec54c32ef2624a3b888b0808b1d140">sc_attr_alloc</a> (struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> **attr_out)</td></tr>
<tr class="memdesc:ga2fec54c32ef2624a3b888b0808b1d140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an attribute object.  <a href="#ga2fec54c32ef2624a3b888b0808b1d140">More...</a><br/></td></tr>
<tr class="separator:ga2fec54c32ef2624a3b888b0808b1d140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga674f74da55d7a68627725b500be874af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga674f74da55d7a68627725b500be874af">sc_attr_free</a> (struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr)</td></tr>
<tr class="memdesc:ga674f74da55d7a68627725b500be874af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an attribute object.  <a href="#ga674f74da55d7a68627725b500be874af">More...</a><br/></td></tr>
<tr class="separator:ga674f74da55d7a68627725b500be874af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3afda524568bd545831ead4b84c78e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga3afda524568bd545831ead4b84c78e90">sc_attr_reset</a> (struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr)</td></tr>
<tr class="memdesc:ga3afda524568bd545831ead4b84c78e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return attributes to their default values.  <a href="#ga3afda524568bd545831ead4b84c78e90">More...</a><br/></td></tr>
<tr class="separator:ga3afda524568bd545831ead4b84c78e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4c5b0938171036d905818462cacdc5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gadd4c5b0938171036d905818462cacdc5">sc_attr_set_int</a> (struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, const char *name, int64_t val)</td></tr>
<tr class="memdesc:gadd4c5b0938171036d905818462cacdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an attribute to an integer value.  <a href="#gadd4c5b0938171036d905818462cacdc5">More...</a><br/></td></tr>
<tr class="separator:gadd4c5b0938171036d905818462cacdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff50aad127b0dec4b286a7d33e06844f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaff50aad127b0dec4b286a7d33e06844f">sc_attr_set_str</a> (struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, const char *name, const char *s)</td></tr>
<tr class="memdesc:gaff50aad127b0dec4b286a7d33e06844f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an attribute to a string value.  <a href="#gaff50aad127b0dec4b286a7d33e06844f">More...</a><br/></td></tr>
<tr class="separator:gaff50aad127b0dec4b286a7d33e06844f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac254aeafb436d9dd073b640a622c34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga0ac254aeafb436d9dd073b640a622c34">sc_attr_set_from_str</a> (struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, const char *name, const char *val)</td></tr>
<tr class="memdesc:ga0ac254aeafb436d9dd073b640a622c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an attribute to a string value.  <a href="#ga0ac254aeafb436d9dd073b640a622c34">More...</a><br/></td></tr>
<tr class="separator:ga0ac254aeafb436d9dd073b640a622c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga897456b8bdec9bab4f0f9613fb776e06"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga897456b8bdec9bab4f0f9613fb776e06">sc_attr_dup</a> (const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr)</td></tr>
<tr class="memdesc:ga897456b8bdec9bab4f0f9613fb776e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate an attribute object.  <a href="#ga897456b8bdec9bab4f0f9613fb776e06">More...</a><br/></td></tr>
<tr class="separator:ga897456b8bdec9bab4f0f9613fb776e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c73aa3cae3a0a3d81159c2fdd24472"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaf4c73aa3cae3a0a3d81159c2fdd24472">sc_attr_doc</a> (const char *attr_name_opt, const char ***docs_out, int *docs_len_out)</td></tr>
<tr class="memdesc:gaf4c73aa3cae3a0a3d81159c2fdd24472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns documentation for attributes. Used by solar_capture_doc.  <a href="#gaf4c73aa3cae3a0a3d81159c2fdd24472">More...</a><br/></td></tr>
<tr class="separator:gaf4c73aa3cae3a0a3d81159c2fdd24472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9d08a80690f21e6d05c9d8bff5beb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gacf9d08a80690f21e6d05c9d8bff5beb2">sc_dlist_init</a> (struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *list)</td></tr>
<tr class="memdesc:gacf9d08a80690f21e6d05c9d8bff5beb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a pre-allocated <a class="el" href="group__scapi.html#structsc__dlist" title="Doubly linked list pointers. ">sc_dlist</a> to be an empty doubly linked list.  <a href="#gacf9d08a80690f21e6d05c9d8bff5beb2">More...</a><br/></td></tr>
<tr class="separator:gacf9d08a80690f21e6d05c9d8bff5beb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf399facac241fd9ff3dfb8749591b145"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf399facac241fd9ff3dfb8749591b145"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaf399facac241fd9ff3dfb8749591b145">sc_dlist_is_empty</a> (const struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *list)</td></tr>
<tr class="memdesc:gaf399facac241fd9ff3dfb8749591b145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a doubly linked list is empty, returns 1 if true 0 otherwise. <br/></td></tr>
<tr class="separator:gaf399facac241fd9ff3dfb8749591b145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23385fa685ba98c0a4dcf5cbbc22b494"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga23385fa685ba98c0a4dcf5cbbc22b494">sc_dlist_push_head</a> (struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *list, struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *l)</td></tr>
<tr class="memdesc:ga23385fa685ba98c0a4dcf5cbbc22b494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend an item to the head of a doubly-linked list.  <a href="#ga23385fa685ba98c0a4dcf5cbbc22b494">More...</a><br/></td></tr>
<tr class="separator:ga23385fa685ba98c0a4dcf5cbbc22b494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga024f7bd3568d222bcb5a5bc1b6a466d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga024f7bd3568d222bcb5a5bc1b6a466d2">sc_dlist_push_tail</a> (struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *list, struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *l)</td></tr>
<tr class="memdesc:ga024f7bd3568d222bcb5a5bc1b6a466d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an item to the tail of a doubly-linked list.  <a href="#ga024f7bd3568d222bcb5a5bc1b6a466d2">More...</a><br/></td></tr>
<tr class="separator:ga024f7bd3568d222bcb5a5bc1b6a466d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebfe64924e412c93836701b93c39f593"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaebfe64924e412c93836701b93c39f593">sc_dlist_remove</a> (struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *l)</td></tr>
<tr class="memdesc:gaebfe64924e412c93836701b93c39f593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an item from the list.  <a href="#gaebfe64924e412c93836701b93c39f593">More...</a><br/></td></tr>
<tr class="separator:gaebfe64924e412c93836701b93c39f593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44bb5607d1f62036a3421a2cddf89390"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga44bb5607d1f62036a3421a2cddf89390">sc_dlist_pop_head</a> (struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *list)</td></tr>
<tr class="memdesc:ga44bb5607d1f62036a3421a2cddf89390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop off the head of a list.  <a href="#ga44bb5607d1f62036a3421a2cddf89390">More...</a><br/></td></tr>
<tr class="separator:ga44bb5607d1f62036a3421a2cddf89390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b09ddf7b724b6bbeefd00ef587dbc80"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga4b09ddf7b724b6bbeefd00ef587dbc80">sc_dlist_pop_tail</a> (struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *list)</td></tr>
<tr class="memdesc:ga4b09ddf7b724b6bbeefd00ef587dbc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the tail of a list.  <a href="#ga4b09ddf7b724b6bbeefd00ef587dbc80">More...</a><br/></td></tr>
<tr class="separator:ga4b09ddf7b724b6bbeefd00ef587dbc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab2d5904cd32a0b610e5241e97b8951f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaab2d5904cd32a0b610e5241e97b8951f">sc_callback_alloc</a> (struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> **cb_out, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, struct sc_thread *thread)</td></tr>
<tr class="memdesc:gaab2d5904cd32a0b610e5241e97b8951f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a callback object instance.  <a href="#gaab2d5904cd32a0b610e5241e97b8951f">More...</a><br/></td></tr>
<tr class="separator:gaab2d5904cd32a0b610e5241e97b8951f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b55e7300bd4998b5145baa500c214d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gab9b55e7300bd4998b5145baa500c214d">sc_callback_free</a> (struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *cb)</td></tr>
<tr class="memdesc:gab9b55e7300bd4998b5145baa500c214d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a callback object instance.  <a href="#gab9b55e7300bd4998b5145baa500c214d">More...</a><br/></td></tr>
<tr class="separator:gab9b55e7300bd4998b5145baa500c214d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1115fec0e84951a84556cb55efbea9b2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga1115fec0e84951a84556cb55efbea9b2">sc_callback_is_active</a> (const struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *cb)</td></tr>
<tr class="memdesc:ga1115fec0e84951a84556cb55efbea9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a callback object is active.  <a href="#ga1115fec0e84951a84556cb55efbea9b2">More...</a><br/></td></tr>
<tr class="separator:ga1115fec0e84951a84556cb55efbea9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccf55062d866893054e81084e4eafc8a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaccf55062d866893054e81084e4eafc8a">sc_callback_remove</a> (struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *cb)</td></tr>
<tr class="memdesc:gaccf55062d866893054e81084e4eafc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a callback object from its event source.  <a href="#gaccf55062d866893054e81084e4eafc8a">More...</a><br/></td></tr>
<tr class="separator:gaccf55062d866893054e81084e4eafc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27afe9adda14a7baf27b27b02f32f80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gae27afe9adda14a7baf27b27b02f32f80">sc_callback_on_idle</a> (struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *cb)</td></tr>
<tr class="memdesc:gae27afe9adda14a7baf27b27b02f32f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a callback when the thread is idle.  <a href="#gae27afe9adda14a7baf27b27b02f32f80">More...</a><br/></td></tr>
<tr class="separator:gae27afe9adda14a7baf27b27b02f32f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c57918e0012ba6fd32371c4db862913"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga6c57918e0012ba6fd32371c4db862913">sc_epoll_ctl</a> (struct sc_thread *thread, int op, int fd, unsigned events, struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *cb)</td></tr>
<tr class="memdesc:ga6c57918e0012ba6fd32371c4db862913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a callback when the thread is idle.  <a href="#ga6c57918e0012ba6fd32371c4db862913">More...</a><br/></td></tr>
<tr class="separator:ga6c57918e0012ba6fd32371c4db862913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0038076a80275fb7bbc9e5358503d3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gab0038076a80275fb7bbc9e5358503d3a">sc_node_type_alloc</a> (struct <a class="el" href="group__scapi.html#structsc__node__type">sc_node_type</a> **nt_out, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr_opt, const struct <a class="el" href="group__scapi.html#structsc__node__factory">sc_node_factory</a> *factory)</td></tr>
<tr class="memdesc:gab0038076a80275fb7bbc9e5358503d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an <a class="el" href="group__scapi.html#structsc__node__type" title="Describes a type of node. ">sc_node_type</a> instance.  <a href="#gab0038076a80275fb7bbc9e5358503d3a">More...</a><br/></td></tr>
<tr class="separator:gab0038076a80275fb7bbc9e5358503d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f892361f4b0bcc985bbf4169be5f80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaf1f892361f4b0bcc985bbf4169be5f80">sc_forward_list</a> (struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a> *link, struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *pl)</td></tr>
<tr class="memdesc:gaf1f892361f4b0bcc985bbf4169be5f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward a list of packets.  <a href="#gaf1f892361f4b0bcc985bbf4169be5f80">More...</a><br/></td></tr>
<tr class="separator:gaf1f892361f4b0bcc985bbf4169be5f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee3bbd8865a6d15ecb982cfbf11bca0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gadee3bbd8865a6d15ecb982cfbf11bca0">sc_forward</a> (struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a> *link, struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *packet)</td></tr>
<tr class="memdesc:gadee3bbd8865a6d15ecb982cfbf11bca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward a single packet.  <a href="#gadee3bbd8865a6d15ecb982cfbf11bca0">More...</a><br/></td></tr>
<tr class="separator:gadee3bbd8865a6d15ecb982cfbf11bca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bd2400efd3c0209a49cc61aacc37a2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga9bd2400efd3c0209a49cc61aacc37a2a">sc_node_init_get_arg_int</a> (int *v_out, struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *name, int v_default)</td></tr>
<tr class="memdesc:ga9bd2400efd3c0209a49cc61aacc37a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an integer argument.  <a href="#ga9bd2400efd3c0209a49cc61aacc37a2a">More...</a><br/></td></tr>
<tr class="separator:ga9bd2400efd3c0209a49cc61aacc37a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a8d3878cb771e5db654686264fae37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga39a8d3878cb771e5db654686264fae37">sc_node_init_get_arg_str</a> (const char **v_out, struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *name, const char *v_default)</td></tr>
<tr class="memdesc:ga39a8d3878cb771e5db654686264fae37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an string argument.  <a href="#ga39a8d3878cb771e5db654686264fae37">More...</a><br/></td></tr>
<tr class="separator:ga39a8d3878cb771e5db654686264fae37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1015ae5984c472c9303da9fa058f22c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga1015ae5984c472c9303da9fa058f22c4">sc_node_init_get_arg_obj</a> (struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> **obj_out, struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *name, enum <a class="el" href="group__scapi.html#ga7dbec837a1592a9f6a4bc649ea583f0d">sc_object_type</a> obj_type)</td></tr>
<tr class="memdesc:ga1015ae5984c472c9303da9fa058f22c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a> argument.  <a href="#ga1015ae5984c472c9303da9fa058f22c4">More...</a><br/></td></tr>
<tr class="separator:ga1015ae5984c472c9303da9fa058f22c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d88678d97b0e12bfce83f727f4946d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gad4d88678d97b0e12bfce83f727f4946d">sc_node_init_get_arg_dbl</a> (double *v_out, struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *name, double v_default)</td></tr>
<tr class="memdesc:gad4d88678d97b0e12bfce83f727f4946d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a double argument.  <a href="#gad4d88678d97b0e12bfce83f727f4946d">More...</a><br/></td></tr>
<tr class="separator:gad4d88678d97b0e12bfce83f727f4946d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60db329829493afd47f6fafee17fe3a4"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga60db329829493afd47f6fafee17fe3a4">sc_node_prep_get_link</a> (struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *link_name)</td></tr>
<tr class="memdesc:ga60db329829493afd47f6fafee17fe3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a named outgoing link.  <a href="#ga60db329829493afd47f6fafee17fe3a4">More...</a><br/></td></tr>
<tr class="separator:ga60db329829493afd47f6fafee17fe3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ed504e3035033bbded0103cee77e18"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga08ed504e3035033bbded0103cee77e18">sc_node_prep_get_link_or_free</a> (struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *link_name)</td></tr>
<tr class="memdesc:ga08ed504e3035033bbded0103cee77e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a named outgoing link or return a link for freeing.  <a href="#ga08ed504e3035033bbded0103cee77e18">More...</a><br/></td></tr>
<tr class="separator:ga08ed504e3035033bbded0103cee77e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812b8c2064d246dda6d27262edadcfb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga812b8c2064d246dda6d27262edadcfb8">sc_node_prep_check_links</a> (struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node)</td></tr>
<tr class="memdesc:ga812b8c2064d246dda6d27262edadcfb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the node's links for any unused links.  <a href="#ga812b8c2064d246dda6d27262edadcfb8">More...</a><br/></td></tr>
<tr class="separator:ga812b8c2064d246dda6d27262edadcfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57655c20c2be20d06739cd948a698fc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga57655c20c2be20d06739cd948a698fc9">sc_node_prep_get_pool</a> (struct sc_pool **pool_out, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a> *const *links, int n_links)</td></tr>
<tr class="memdesc:ga57655c20c2be20d06739cd948a698fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a packet pool that can be used to obtain empty packet buffers that can be passed to any of the given set of links.  <a href="#ga57655c20c2be20d06739cd948a698fc9">More...</a><br/></td></tr>
<tr class="separator:ga57655c20c2be20d06739cd948a698fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a56ca7cf9cb5339613bb8c3414662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga31a56ca7cf9cb5339613bb8c3414662d">sc_node_link_end_of_stream</a> (struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a> *link)</td></tr>
<tr class="memdesc:ga31a56ca7cf9cb5339613bb8c3414662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate end-of-stream on a link.  <a href="#ga31a56ca7cf9cb5339613bb8c3414662d">More...</a><br/></td></tr>
<tr class="separator:ga31a56ca7cf9cb5339613bb8c3414662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc6af7c03d777dc736d6d8bdba1dead2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gacc6af7c03d777dc736d6d8bdba1dead2">sc_node_export_state</a> (struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *type_name, int type_size, void *pp_area)</td></tr>
<tr class="memdesc:gacc6af7c03d777dc736d6d8bdba1dead2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export dynamic state to solar_capture_monitor.  <a href="#gacc6af7c03d777dc736d6d8bdba1dead2">More...</a><br/></td></tr>
<tr class="separator:gacc6af7c03d777dc736d6d8bdba1dead2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86a57ce4b42726de7c3f19d0db72e29b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga86a57ce4b42726de7c3f19d0db72e29b">sc_packet_bytes</a> (struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *p)</td></tr>
<tr class="memdesc:ga86a57ce4b42726de7c3f19d0db72e29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the packet data in bytes.  <a href="#ga86a57ce4b42726de7c3f19d0db72e29b">More...</a><br/></td></tr>
<tr class="separator:ga86a57ce4b42726de7c3f19d0db72e29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f913fe7a127765c02a200e939f5ecc8"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga0f913fe7a127765c02a200e939f5ecc8">sc_packet_frags_tail</a> (struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *p)</td></tr>
<tr class="memdesc:ga0f913fe7a127765c02a200e939f5ecc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a packet's last fragment.  <a href="#ga0f913fe7a127765c02a200e939f5ecc8">More...</a><br/></td></tr>
<tr class="separator:ga0f913fe7a127765c02a200e939f5ecc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49aadbcf993ff1eac6009514e66d1fba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga49aadbcf993ff1eac6009514e66d1fba">sc_packet_prefetch_r</a> (struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *p)</td></tr>
<tr class="memdesc:ga49aadbcf993ff1eac6009514e66d1fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch a packet for reading.  <a href="#ga49aadbcf993ff1eac6009514e66d1fba">More...</a><br/></td></tr>
<tr class="separator:ga49aadbcf993ff1eac6009514e66d1fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f0139e0b61551a63b7581e1aa7f7167"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga2f0139e0b61551a63b7581e1aa7f7167">sc_packet_prefetch_rw</a> (struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *p)</td></tr>
<tr class="memdesc:ga2f0139e0b61551a63b7581e1aa7f7167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch a packet for reading and writing.  <a href="#ga2f0139e0b61551a63b7581e1aa7f7167">More...</a><br/></td></tr>
<tr class="separator:ga2f0139e0b61551a63b7581e1aa7f7167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3803622499b77c68d60e5c281d6f3f21"><td class="memItemLeft" align="right" valign="top">static struct timespec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga3803622499b77c68d60e5c281d6f3f21">sc_packet_timespec</a> (const struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *p)</td></tr>
<tr class="memdesc:ga3803622499b77c68d60e5c281d6f3f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the timestamp of the packet in timespec format.  <a href="#ga3803622499b77c68d60e5c281d6f3f21">More...</a><br/></td></tr>
<tr class="separator:ga3803622499b77c68d60e5c281d6f3f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga800166fc20af90e8ffd591fd56a502df"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga800166fc20af90e8ffd591fd56a502df">sc_packet_list_init</a> (struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *l)</td></tr>
<tr class="memdesc:ga800166fc20af90e8ffd591fd56a502df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a list.  <a href="#ga800166fc20af90e8ffd591fd56a502df">More...</a><br/></td></tr>
<tr class="separator:ga800166fc20af90e8ffd591fd56a502df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a5023853852a43058414361b743cf86"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga3a5023853852a43058414361b743cf86">sc_packet_list_is_empty</a> (const struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *l)</td></tr>
<tr class="memdesc:ga3a5023853852a43058414361b743cf86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if packet list is empty.  <a href="#ga3a5023853852a43058414361b743cf86">More...</a><br/></td></tr>
<tr class="separator:ga3a5023853852a43058414361b743cf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27605a80d75a6e52df01dd7a5a70cb1c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga27605a80d75a6e52df01dd7a5a70cb1c">sc_packet_list_finalise</a> (struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *l)</td></tr>
<tr class="memdesc:ga27605a80d75a6e52df01dd7a5a70cb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise a list.  <a href="#ga27605a80d75a6e52df01dd7a5a70cb1c">More...</a><br/></td></tr>
<tr class="separator:ga27605a80d75a6e52df01dd7a5a70cb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf16773cf50c92ce8a87d0afe1798e15c"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaf16773cf50c92ce8a87d0afe1798e15c">sc_packet_list_tail</a> (struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *l)</td></tr>
<tr class="memdesc:gaf16773cf50c92ce8a87d0afe1798e15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tail of current tail of the list.  <a href="#gaf16773cf50c92ce8a87d0afe1798e15c">More...</a><br/></td></tr>
<tr class="separator:gaf16773cf50c92ce8a87d0afe1798e15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8843276b4c2fdb4d4dcc38dbd9f290f4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga8843276b4c2fdb4d4dcc38dbd9f290f4">sc_packet_list_push_head</a> (struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *pl, struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *p)</td></tr>
<tr class="memdesc:ga8843276b4c2fdb4d4dcc38dbd9f290f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a packet to the head of a list.  <a href="#ga8843276b4c2fdb4d4dcc38dbd9f290f4">More...</a><br/></td></tr>
<tr class="separator:ga8843276b4c2fdb4d4dcc38dbd9f290f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1466e528075a1601af2fbd69c2e14dc3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga1466e528075a1601af2fbd69c2e14dc3">sc_packet_list_append</a> (struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *l, struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *p)</td></tr>
<tr class="memdesc:ga1466e528075a1601af2fbd69c2e14dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a packet to a list and finalise.  <a href="#ga1466e528075a1601af2fbd69c2e14dc3">More...</a><br/></td></tr>
<tr class="separator:ga1466e528075a1601af2fbd69c2e14dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9383f0aeb20125c7433a9d4929cbcabe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga9383f0aeb20125c7433a9d4929cbcabe">sc_packet_list_append_list</a> (struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *dest, struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *src)</td></tr>
<tr class="memdesc:ga9383f0aeb20125c7433a9d4929cbcabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a list to a list.  <a href="#ga9383f0aeb20125c7433a9d4929cbcabe">More...</a><br/></td></tr>
<tr class="separator:ga9383f0aeb20125c7433a9d4929cbcabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad713ca3a98e3e6146ea8c2252553201e"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gad713ca3a98e3e6146ea8c2252553201e">sc_packet_list_pop_head</a> (struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *pl)</td></tr>
<tr class="memdesc:gad713ca3a98e3e6146ea8c2252553201e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return the head of the list.  <a href="#gad713ca3a98e3e6146ea8c2252553201e">More...</a><br/></td></tr>
<tr class="separator:gad713ca3a98e3e6146ea8c2252553201e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2802f23482b81e3bc832168758ee4e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gabd2802f23482b81e3bc832168758ee4e">sc_iovec_ptr_init</a> (struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *iovp, const struct iovec *iov, int iovlen)</td></tr>
<tr class="memdesc:gabd2802f23482b81e3bc832168758ee4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a>.  <a href="#gabd2802f23482b81e3bc832168758ee4e">More...</a><br/></td></tr>
<tr class="separator:gabd2802f23482b81e3bc832168758ee4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3852fd32e1bed2681c6bec7b97998ca0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga3852fd32e1bed2681c6bec7b97998ca0">sc_iovec_ptr_init_buf</a> (struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *iovp, void *buf, int len)</td></tr>
<tr class="memdesc:ga3852fd32e1bed2681c6bec7b97998ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> with a contiguous buffer.  <a href="#ga3852fd32e1bed2681c6bec7b97998ca0">More...</a><br/></td></tr>
<tr class="separator:ga3852fd32e1bed2681c6bec7b97998ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4fe4eb92533707504279c26e57671a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gac4fe4eb92533707504279c26e57671a2">sc_iovec_ptr_init_packet</a> (struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *iovp, const struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *packet)</td></tr>
<tr class="memdesc:gac4fe4eb92533707504279c26e57671a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> to point at packet data.  <a href="#gac4fe4eb92533707504279c26e57671a2">More...</a><br/></td></tr>
<tr class="separator:gac4fe4eb92533707504279c26e57671a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac22fd8469d900114d03992219c2b3417"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gac22fd8469d900114d03992219c2b3417">sc_iovec_ptr_bytes</a> (const struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *iovp)</td></tr>
<tr class="memdesc:gac22fd8469d900114d03992219c2b3417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes represented by an <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a>.  <a href="#gac22fd8469d900114d03992219c2b3417">More...</a><br/></td></tr>
<tr class="separator:gac22fd8469d900114d03992219c2b3417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73af931693a9526598e23b1800450c8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga73af931693a9526598e23b1800450c8a">sc_iovec_ptr_skip</a> (struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *iovp, int bytes_to_skip)</td></tr>
<tr class="memdesc:ga73af931693a9526598e23b1800450c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip forward over an iovec.  <a href="#ga73af931693a9526598e23b1800450c8a">More...</a><br/></td></tr>
<tr class="separator:ga73af931693a9526598e23b1800450c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac84607d24ee7dc21304f5a60bd7e75f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gac84607d24ee7dc21304f5a60bd7e75f1">sc_iovec_ptr_find_chr</a> (const struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *iovp, int c)</td></tr>
<tr class="memdesc:gac84607d24ee7dc21304f5a60bd7e75f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find offset of character in iovec.  <a href="#gac84607d24ee7dc21304f5a60bd7e75f1">More...</a><br/></td></tr>
<tr class="separator:gac84607d24ee7dc21304f5a60bd7e75f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7e58a9665f7fdfad4bd7791de96504d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gad7e58a9665f7fdfad4bd7791de96504d">sc_iovec_ptr_copy_out</a> (void *dest, struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *iovp, int max_bytes)</td></tr>
<tr class="memdesc:gad7e58a9665f7fdfad4bd7791de96504d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data out of an <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a>.  <a href="#gad7e58a9665f7fdfad4bd7791de96504d">More...</a><br/></td></tr>
<tr class="separator:gad7e58a9665f7fdfad4bd7791de96504d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae97f0c16c9d01b4e3e647b6a178dffad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gae97f0c16c9d01b4e3e647b6a178dffad">sc_iovec_copy_from_end</a> (void *dest_buf, const struct iovec *iov, int iovlen, int bytes)</td></tr>
<tr class="memdesc:gae97f0c16c9d01b4e3e647b6a178dffad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data out of the end of a <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a>.  <a href="#gae97f0c16c9d01b4e3e647b6a178dffad">More...</a><br/></td></tr>
<tr class="separator:gae97f0c16c9d01b4e3e647b6a178dffad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3b02ad7e88dbdf27de5bc408bf48b89"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gae3b02ad7e88dbdf27de5bc408bf48b89">sc_iovec_trim_end</a> (struct iovec *iov, uint8_t *iovlen, int bytes)</td></tr>
<tr class="memdesc:gae3b02ad7e88dbdf27de5bc408bf48b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove data from the end of an iovec.  <a href="#gae3b02ad7e88dbdf27de5bc408bf48b89">More...</a><br/></td></tr>
<tr class="separator:gae3b02ad7e88dbdf27de5bc408bf48b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4432c58f316ec4937aa3c0610a522c85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga4432c58f316ec4937aa3c0610a522c85">sc_mailbox_alloc</a> (struct sc_mailbox **mb_out, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, struct sc_thread *thread)</td></tr>
<tr class="memdesc:ga4432c58f316ec4937aa3c0610a522c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a mailbox.  <a href="#ga4432c58f316ec4937aa3c0610a522c85">More...</a><br/></td></tr>
<tr class="separator:ga4432c58f316ec4937aa3c0610a522c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga179658a5950075de502cf74c5ab7a620"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga179658a5950075de502cf74c5ab7a620">sc_mailbox_connect</a> (struct sc_mailbox *mb1, struct sc_mailbox *mb2)</td></tr>
<tr class="memdesc:ga179658a5950075de502cf74c5ab7a620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect a pair of mailboxes.  <a href="#ga179658a5950075de502cf74c5ab7a620">More...</a><br/></td></tr>
<tr class="separator:ga179658a5950075de502cf74c5ab7a620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e3b4c2ee7e80fb5e118f9cc9303258"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gad4e3b4c2ee7e80fb5e118f9cc9303258">sc_mailbox_set_recv</a> (struct sc_mailbox *mailbox, struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *name_opt)</td></tr>
<tr class="memdesc:gad4e3b4c2ee7e80fb5e118f9cc9303258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect a mailbox to a node.  <a href="#gad4e3b4c2ee7e80fb5e118f9cc9303258">More...</a><br/></td></tr>
<tr class="separator:gad4e3b4c2ee7e80fb5e118f9cc9303258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5104493c626279ce8480e7e42ef1a88a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga5104493c626279ce8480e7e42ef1a88a">sc_mailbox_get_send_node</a> (struct sc_mailbox *mailbox)</td></tr>
<tr class="memdesc:ga5104493c626279ce8480e7e42ef1a88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mailbox's "send node".  <a href="#ga5104493c626279ce8480e7e42ef1a88a">More...</a><br/></td></tr>
<tr class="separator:ga5104493c626279ce8480e7e42ef1a88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab280593925991f558ba413315f93a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga2ab280593925991f558ba413315f93a3">sc_mailbox_poll</a> (struct sc_mailbox *mailbox, struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *list)</td></tr>
<tr class="memdesc:ga2ab280593925991f558ba413315f93a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll a mailbox.  <a href="#ga2ab280593925991f558ba413315f93a3">More...</a><br/></td></tr>
<tr class="separator:ga2ab280593925991f558ba413315f93a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadde326f7b7b77418c060c523c9beaa30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gadde326f7b7b77418c060c523c9beaa30">sc_mailbox_send</a> (struct sc_mailbox *mailbox, struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *packet)</td></tr>
<tr class="memdesc:gadde326f7b7b77418c060c523c9beaa30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a packet through a mailbox to another thread.  <a href="#gadde326f7b7b77418c060c523c9beaa30">More...</a><br/></td></tr>
<tr class="separator:gadde326f7b7b77418c060c523c9beaa30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98342f5d3bea6b55223081ef8badd378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga98342f5d3bea6b55223081ef8badd378">sc_mailbox_send_list</a> (struct sc_mailbox *mailbox, struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *list)</td></tr>
<tr class="memdesc:ga98342f5d3bea6b55223081ef8badd378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a list of packets through a mailbox to another thread.  <a href="#ga98342f5d3bea6b55223081ef8badd378">More...</a><br/></td></tr>
<tr class="separator:ga98342f5d3bea6b55223081ef8badd378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga674346831bf77ab6b65955ac013d47a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga674346831bf77ab6b65955ac013d47a5">sc_join_mcast_group</a> (struct sc_session *scs, const char *interface, const char *group)</td></tr>
<tr class="memdesc:ga674346831bf77ab6b65955ac013d47a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a multicast group.  <a href="#ga674346831bf77ab6b65955ac013d47a5">More...</a><br/></td></tr>
<tr class="separator:ga674346831bf77ab6b65955ac013d47a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15eae832e9b93996b7ee5e311c991cf4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga15eae832e9b93996b7ee5e311c991cf4">sc_node_alloc</a> (struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> **node_out, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, struct sc_thread *thread, const struct <a class="el" href="group__scapi.html#structsc__node__factory">sc_node_factory</a> *factory, const struct <a class="el" href="group__scapi.html#structsc__arg">sc_arg</a> *args, int n_args)</td></tr>
<tr class="memdesc:ga15eae832e9b93996b7ee5e311c991cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a packet processing node.  <a href="#ga15eae832e9b93996b7ee5e311c991cf4">More...</a><br/></td></tr>
<tr class="separator:ga15eae832e9b93996b7ee5e311c991cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a27a36506cdbb62afcaaeb812ef1b6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga7a27a36506cdbb62afcaaeb812ef1b6e">sc_node_alloc_named</a> (struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> **node_out, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, struct sc_thread *thread, const char *factory_name, const char *lib_name, const struct <a class="el" href="group__scapi.html#structsc__arg">sc_arg</a> *args, int n_args)</td></tr>
<tr class="memdesc:ga7a27a36506cdbb62afcaaeb812ef1b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a packet processing node by name.  <a href="#ga7a27a36506cdbb62afcaaeb812ef1b6e">More...</a><br/></td></tr>
<tr class="separator:ga7a27a36506cdbb62afcaaeb812ef1b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25ee0880d5b47c78a5d1b07926f9fb4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga25ee0880d5b47c78a5d1b07926f9fb4d">sc_node_add_link</a> (struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *from_node, const char *link_name, struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *to_node, const char *to_name_opt)</td></tr>
<tr class="memdesc:ga25ee0880d5b47c78a5d1b07926f9fb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a link from one node to another.  <a href="#ga25ee0880d5b47c78a5d1b07926f9fb4d">More...</a><br/></td></tr>
<tr class="separator:ga25ee0880d5b47c78a5d1b07926f9fb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad96a64c4b5acc86bf4f034ddabc94759"><td class="memItemLeft" align="right" valign="top">struct sc_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gad96a64c4b5acc86bf4f034ddabc94759">sc_node_get_thread</a> (const struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node)</td></tr>
<tr class="memdesc:gad96a64c4b5acc86bf4f034ddabc94759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread associated with a node.  <a href="#gad96a64c4b5acc86bf4f034ddabc94759">More...</a><br/></td></tr>
<tr class="separator:gad96a64c4b5acc86bf4f034ddabc94759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa1ef25849867e989035103317980d50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gafa1ef25849867e989035103317980d50">sc_node_factory_lookup</a> (const struct <a class="el" href="group__scapi.html#structsc__node__factory">sc_node_factory</a> **factory_out, struct sc_session *session, const char *factory_name, const char *lib_name)</td></tr>
<tr class="memdesc:gafa1ef25849867e989035103317980d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node factory.  <a href="#gafa1ef25849867e989035103317980d50">More...</a><br/></td></tr>
<tr class="separator:gafa1ef25849867e989035103317980d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9ffadf72bc8ee9acda36d8c44253fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga3a9ffadf72bc8ee9acda36d8c44253fe">sc_node_add_info_str</a> (struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *field_name, const char *field_val)</td></tr>
<tr class="memdesc:ga3a9ffadf72bc8ee9acda36d8c44253fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export information to solar_capture_monitor.  <a href="#ga3a9ffadf72bc8ee9acda36d8c44253fe">More...</a><br/></td></tr>
<tr class="separator:ga3a9ffadf72bc8ee9acda36d8c44253fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf52bfbee29e202cd9c1e23ecce47fb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaaf52bfbee29e202cd9c1e23ecce47fb1">sc_node_add_info_int</a> (struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *field_name, int64_t field_val)</td></tr>
<tr class="memdesc:gaaf52bfbee29e202cd9c1e23ecce47fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export information to solar_capture_monitor.  <a href="#gaaf52bfbee29e202cd9c1e23ecce47fb1">More...</a><br/></td></tr>
<tr class="separator:gaaf52bfbee29e202cd9c1e23ecce47fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8d3d54946468e02b0ff6cfd3da9011"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__scapi.html#ga7dbec837a1592a9f6a4bc649ea583f0d">sc_object_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga1f8d3d54946468e02b0ff6cfd3da9011">sc_object_type</a> (struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> *obj)</td></tr>
<tr class="memdesc:ga1f8d3d54946468e02b0ff6cfd3da9011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of data contained within the <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>.  <a href="#ga1f8d3d54946468e02b0ff6cfd3da9011">More...</a><br/></td></tr>
<tr class="separator:ga1f8d3d54946468e02b0ff6cfd3da9011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf52b03c8c1928ed4c3f4d2a16961dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga5cf52b03c8c1928ed4c3f4d2a16961dd">sc_opaque_alloc</a> (struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> **obj_out, void *opaque)</td></tr>
<tr class="memdesc:ga5cf52b03c8c1928ed4c3f4d2a16961dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for an opaque <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>.  <a href="#ga5cf52b03c8c1928ed4c3f4d2a16961dd">More...</a><br/></td></tr>
<tr class="separator:ga5cf52b03c8c1928ed4c3f4d2a16961dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4eb6fd151e9e6765dd4f643a4fe5fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga3b4eb6fd151e9e6765dd4f643a4fe5fb">sc_opaque_free</a> (struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> *obj)</td></tr>
<tr class="memdesc:ga3b4eb6fd151e9e6765dd4f643a4fe5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a> previously allocated using <a class="el" href="group__scapi.html#ga5cf52b03c8c1928ed4c3f4d2a16961dd" title="Allocate memory for an opaque sc_object. ">sc_opaque_alloc</a>. Only use this to free an opaque <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>. The underlying data wrapped by this object will not be freed.  <a href="#ga3b4eb6fd151e9e6765dd4f643a4fe5fb">More...</a><br/></td></tr>
<tr class="separator:ga3b4eb6fd151e9e6765dd4f643a4fe5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab8278ca64eaa658b719cc965b0e3ee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaab8278ca64eaa658b719cc965b0e3ee6">sc_opaque_set_ptr</a> (struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> *obj, void *opaque)</td></tr>
<tr class="memdesc:gaab8278ca64eaa658b719cc965b0e3ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the opaque pointer in an <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>.  <a href="#gaab8278ca64eaa658b719cc965b0e3ee6">More...</a><br/></td></tr>
<tr class="separator:gaab8278ca64eaa658b719cc965b0e3ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b65f0f7cfa229dcca425ea077e2c55b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga6b65f0f7cfa229dcca425ea077e2c55b">sc_opaque_get_ptr</a> (const struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> *obj)</td></tr>
<tr class="memdesc:ga6b65f0f7cfa229dcca425ea077e2c55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the opaque pointer stored in an <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>.  <a href="#ga6b65f0f7cfa229dcca425ea077e2c55b">More...</a><br/></td></tr>
<tr class="separator:ga6b65f0f7cfa229dcca425ea077e2c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f076c7861f6500e193ad2f25b436ad1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga8f076c7861f6500e193ad2f25b436ad1">sc_pool_get_packets</a> (struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *list, struct sc_pool *pool, int min_packets, int max_packets)</td></tr>
<tr class="memdesc:ga8f076c7861f6500e193ad2f25b436ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get packet buffers from a pool.  <a href="#ga8f076c7861f6500e193ad2f25b436ad1">More...</a><br/></td></tr>
<tr class="separator:ga8f076c7861f6500e193ad2f25b436ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845097c04ecb97bc8769111d8ae94a98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga845097c04ecb97bc8769111d8ae94a98">sc_pool_return_packets</a> (struct sc_pool *pool, struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *list)</td></tr>
<tr class="memdesc:ga845097c04ecb97bc8769111d8ae94a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return packets to a pool.  <a href="#ga845097c04ecb97bc8769111d8ae94a98">More...</a><br/></td></tr>
<tr class="separator:ga845097c04ecb97bc8769111d8ae94a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab65a15a5724e993cd3b819006d3a0ea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gab65a15a5724e993cd3b819006d3a0ea4">sc_pool_on_threshold</a> (struct sc_pool *pool, struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *event, int threshold)</td></tr>
<tr class="memdesc:gab65a15a5724e993cd3b819006d3a0ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a callback when the pool is refilled.  <a href="#gab65a15a5724e993cd3b819006d3a0ea4">More...</a><br/></td></tr>
<tr class="separator:gab65a15a5724e993cd3b819006d3a0ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43bdfc20c5bd5ee6fa5fe0ca4e83c893"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga43bdfc20c5bd5ee6fa5fe0ca4e83c893">sc_pool_duplicate_packet</a> (struct sc_pool *pool, struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *packet, int snap)</td></tr>
<tr class="memdesc:ga43bdfc20c5bd5ee6fa5fe0ca4e83c893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a packet.  <a href="#ga43bdfc20c5bd5ee6fa5fe0ca4e83c893">More...</a><br/></td></tr>
<tr class="separator:ga43bdfc20c5bd5ee6fa5fe0ca4e83c893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8093bbe733b0222fbca55585685ac16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gad8093bbe733b0222fbca55585685ac16">sc_packet_append_iovec_ptr</a> (struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *packet, struct sc_pool *pool, struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *iovp, int snap)</td></tr>
<tr class="memdesc:gad8093bbe733b0222fbca55585685ac16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append data to a packet.  <a href="#gad8093bbe733b0222fbca55585685ac16">More...</a><br/></td></tr>
<tr class="separator:gad8093bbe733b0222fbca55585685ac16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35454255cfdaa226a20011eecbc330db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga35454255cfdaa226a20011eecbc330db">sc_pkt_predicate_alloc</a> (struct <a class="el" href="group__scapi.html#structsc__pkt__predicate">sc_pkt_predicate</a> **pred_out, int private_bytes)</td></tr>
<tr class="memdesc:ga35454255cfdaa226a20011eecbc330db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a packet predicate object.  <a href="#ga35454255cfdaa226a20011eecbc330db">More...</a><br/></td></tr>
<tr class="separator:ga35454255cfdaa226a20011eecbc330db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774b93770aa8945186b1cc2fc589049a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga774b93770aa8945186b1cc2fc589049a">sc_pkt_predicate_to_object</a> (struct <a class="el" href="group__scapi.html#structsc__pkt__predicate">sc_pkt_predicate</a> *pred)</td></tr>
<tr class="memdesc:ga774b93770aa8945186b1cc2fc589049a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="group__scapi.html#structsc__pkt__predicate" title="A packet predicate object. ">sc_pkt_predicate</a> into a <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>.  <a href="#ga774b93770aa8945186b1cc2fc589049a">More...</a><br/></td></tr>
<tr class="separator:ga774b93770aa8945186b1cc2fc589049a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b31433e450ec1a8e237b412fc42c338"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__scapi.html#structsc__pkt__predicate">sc_pkt_predicate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga4b31433e450ec1a8e237b412fc42c338">sc_pkt_predicate_from_object</a> (struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> *obj)</td></tr>
<tr class="memdesc:ga4b31433e450ec1a8e237b412fc42c338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a> into a <a class="el" href="group__scapi.html#structsc__pkt__predicate" title="A packet predicate object. ">sc_pkt_predicate</a>.  <a href="#ga4b31433e450ec1a8e237b412fc42c338">More...</a><br/></td></tr>
<tr class="separator:ga4b31433e450ec1a8e237b412fc42c338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb3b520ff2455e773c8328e52665dcd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaeb3b520ff2455e773c8328e52665dcd2">sc_session_alloc</a> (struct sc_session **scs_out, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr)</td></tr>
<tr class="memdesc:gaeb3b520ff2455e773c8328e52665dcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a SolarCapture session.  <a href="#gaeb3b520ff2455e773c8328e52665dcd2">More...</a><br/></td></tr>
<tr class="separator:gaeb3b520ff2455e773c8328e52665dcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51670c28c622d5628e4556079707b39f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga51670c28c622d5628e4556079707b39f">sc_session_prepare</a> (struct sc_session *scs)</td></tr>
<tr class="memdesc:ga51670c28c622d5628e4556079707b39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a SolarCapture session.  <a href="#ga51670c28c622d5628e4556079707b39f">More...</a><br/></td></tr>
<tr class="separator:ga51670c28c622d5628e4556079707b39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ce051535aeecdd0d0c5dc29e3ff4ed4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga7ce051535aeecdd0d0c5dc29e3ff4ed4">sc_session_go</a> (struct sc_session *scs)</td></tr>
<tr class="memdesc:ga7ce051535aeecdd0d0c5dc29e3ff4ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a SolarCapture session.  <a href="#ga7ce051535aeecdd0d0c5dc29e3ff4ed4">More...</a><br/></td></tr>
<tr class="separator:ga7ce051535aeecdd0d0c5dc29e3ff4ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0b0679c812770607440d7cbd6dff06a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gad0b0679c812770607440d7cbd6dff06a">sc_session_pause</a> (struct sc_session *scs)</td></tr>
<tr class="memdesc:gad0b0679c812770607440d7cbd6dff06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause a SolarCapture session.  <a href="#gad0b0679c812770607440d7cbd6dff06a">More...</a><br/></td></tr>
<tr class="separator:gad0b0679c812770607440d7cbd6dff06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2ed816358bceda7232241aec4a56fc2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__scapi.html#structsc__session__error">sc_session_error</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaa2ed816358bceda7232241aec4a56fc2">sc_session_error_get</a> (struct sc_session *scs)</td></tr>
<tr class="memdesc:gaa2ed816358bceda7232241aec4a56fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an error from a SolarCapture session.  <a href="#gaa2ed816358bceda7232241aec4a56fc2">More...</a><br/></td></tr>
<tr class="separator:gaa2ed816358bceda7232241aec4a56fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38fd2b69598273e1fa68698f7f1a6e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga38fd2b69598273e1fa68698f7f1a6e7f">sc_session_error_free</a> (struct sc_session *scs, struct <a class="el" href="group__scapi.html#structsc__session__error">sc_session_error</a> *err)</td></tr>
<tr class="memdesc:ga38fd2b69598273e1fa68698f7f1a6e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an error object.  <a href="#ga38fd2b69598273e1fa68698f7f1a6e7f">More...</a><br/></td></tr>
<tr class="separator:ga38fd2b69598273e1fa68698f7f1a6e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f28b2f34cfb3987a0d033f548578521"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga2f28b2f34cfb3987a0d033f548578521">sc_stream_alloc</a> (struct sc_stream **stream_out, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, struct sc_session *scs)</td></tr>
<tr class="memdesc:ga2f28b2f34cfb3987a0d033f548578521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new stream object for this session.  <a href="#ga2f28b2f34cfb3987a0d033f548578521">More...</a><br/></td></tr>
<tr class="separator:ga2f28b2f34cfb3987a0d033f548578521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ccf1f450ad2ed7193b0972654d7b4aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga7ccf1f450ad2ed7193b0972654d7b4aa">sc_stream_free</a> (struct sc_stream *stream)</td></tr>
<tr class="memdesc:ga7ccf1f450ad2ed7193b0972654d7b4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a previously created stream.  <a href="#ga7ccf1f450ad2ed7193b0972654d7b4aa">More...</a><br/></td></tr>
<tr class="separator:ga7ccf1f450ad2ed7193b0972654d7b4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42cd4eec7735d8ce35ecec8d86dee695"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga42cd4eec7735d8ce35ecec8d86dee695">sc_stream_reset</a> (struct sc_stream *stream)</td></tr>
<tr class="memdesc:ga42cd4eec7735d8ce35ecec8d86dee695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all stream filters.  <a href="#ga42cd4eec7735d8ce35ecec8d86dee695">More...</a><br/></td></tr>
<tr class="separator:ga42cd4eec7735d8ce35ecec8d86dee695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd0ac0a3c54818e422378be2ab9419e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga3bd0ac0a3c54818e422378be2ab9419e">sc_stream_set_str</a> (struct sc_stream *stream, const char *str)</td></tr>
<tr class="memdesc:ga3bd0ac0a3c54818e422378be2ab9419e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the stream to capture all packets matching the specified filter string. This is the preferred way of adding filters to a stream.  <a href="#ga3bd0ac0a3c54818e422378be2ab9419e">More...</a><br/></td></tr>
<tr class="separator:ga3bd0ac0a3c54818e422378be2ab9419e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga030ee27014d1cdb02a585692aa080d4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga030ee27014d1cdb02a585692aa080d4a">sc_stream_all</a> (struct sc_stream *stream)</td></tr>
<tr class="memdesc:ga030ee27014d1cdb02a585692aa080d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this stream to capture all packets that haven't been caught by another stream.  <a href="#ga030ee27014d1cdb02a585692aa080d4a">More...</a><br/></td></tr>
<tr class="separator:ga030ee27014d1cdb02a585692aa080d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa085b627b12075d9df4f6515e831b455"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaa085b627b12075d9df4f6515e831b455">sc_stream_mismatch</a> (struct sc_stream *stream)</td></tr>
<tr class="memdesc:gaa085b627b12075d9df4f6515e831b455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this stream to capture all packets that haven't been caught by another stream and are not requested by the kernel network stack.  <a href="#gaa085b627b12075d9df4f6515e831b455">More...</a><br/></td></tr>
<tr class="separator:gaa085b627b12075d9df4f6515e831b455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b44193c6dc23afc8c5084c46408fa5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga5b44193c6dc23afc8c5084c46408fa5b">sc_stream_ip_dest_hostport</a> (struct sc_stream *stream, int protocol, const char *dhost, const char *dport)</td></tr>
<tr class="memdesc:ga5b44193c6dc23afc8c5084c46408fa5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this stream to capture all packets with the matching protocol, destination hostname and destination port.  <a href="#ga5b44193c6dc23afc8c5084c46408fa5b">More...</a><br/></td></tr>
<tr class="separator:ga5b44193c6dc23afc8c5084c46408fa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d7cf2e688403f3471166cc29e9cb496"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga3d7cf2e688403f3471166cc29e9cb496">sc_stream_ip_source_hostport</a> (struct sc_stream *stream, const char *shost, const char *sport)</td></tr>
<tr class="memdesc:ga3d7cf2e688403f3471166cc29e9cb496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this stream to capture all packets with the matching protocol, source hostname and source port.  <a href="#ga3d7cf2e688403f3471166cc29e9cb496">More...</a><br/></td></tr>
<tr class="separator:ga3d7cf2e688403f3471166cc29e9cb496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga560887a0eba175ff112a7bd397f60bf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga560887a0eba175ff112a7bd397f60bf9">sc_stream_eth_dhost</a> (struct sc_stream *stream, const uint8_t *mac_addr)</td></tr>
<tr class="memdesc:ga560887a0eba175ff112a7bd397f60bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this stream to capture all packets with the matching destination MAC address.  <a href="#ga560887a0eba175ff112a7bd397f60bf9">More...</a><br/></td></tr>
<tr class="separator:ga560887a0eba175ff112a7bd397f60bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dfd4b9ce0e999709c99595671457815"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga4dfd4b9ce0e999709c99595671457815">sc_stream_eth_vlan_id</a> (struct sc_stream *stream, int vlan_id)</td></tr>
<tr class="memdesc:ga4dfd4b9ce0e999709c99595671457815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this stream to capture all packets with the matching VLAN ID.  <a href="#ga4dfd4b9ce0e999709c99595671457815">More...</a><br/></td></tr>
<tr class="separator:ga4dfd4b9ce0e999709c99595671457815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c29f537440d7ab981724ae5694210a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga9c29f537440d7ab981724ae5694210a5">sc_stream_eth_shost</a> (struct sc_stream *stream, const uint8_t *mac_addr)</td></tr>
<tr class="memdesc:ga9c29f537440d7ab981724ae5694210a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this stream to capture all packets with the matching source MAC address.  <a href="#ga9c29f537440d7ab981724ae5694210a5">More...</a><br/></td></tr>
<tr class="separator:ga9c29f537440d7ab981724ae5694210a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafdd45b9c9cd2b3d9bbed484edb039ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaafdd45b9c9cd2b3d9bbed484edb039ce">sc_stream_eth_type</a> (struct sc_stream *stream, uint16_t eth_type)</td></tr>
<tr class="memdesc:gaafdd45b9c9cd2b3d9bbed484edb039ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configrue this stream to capture all packets with the matching ethernet type.  <a href="#gaafdd45b9c9cd2b3d9bbed484edb039ce">More...</a><br/></td></tr>
<tr class="separator:gaafdd45b9c9cd2b3d9bbed484edb039ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e35061b4f1eb046e2ed9643d43f92b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga6e35061b4f1eb046e2ed9643d43f92b4">sc_stream_ip_dest_host</a> (struct sc_stream *stream, const char *dhost)</td></tr>
<tr class="memdesc:ga6e35061b4f1eb046e2ed9643d43f92b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this stream to capture all packets with matching destination hostname.  <a href="#ga6e35061b4f1eb046e2ed9643d43f92b4">More...</a><br/></td></tr>
<tr class="separator:ga6e35061b4f1eb046e2ed9643d43f92b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab53fdb27f1a14621f163fbb133b7aa5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaab53fdb27f1a14621f163fbb133b7aa5">sc_stream_ip_dest_port</a> (struct sc_stream *stream, const char *dport)</td></tr>
<tr class="memdesc:gaab53fdb27f1a14621f163fbb133b7aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this stream to capture all packets with matching destination port.  <a href="#gaab53fdb27f1a14621f163fbb133b7aa5">More...</a><br/></td></tr>
<tr class="separator:gaab53fdb27f1a14621f163fbb133b7aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f858951323a44d4ce0525d58b6b442"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gad3f858951323a44d4ce0525d58b6b442">sc_stream_ip_source_host</a> (struct sc_stream *stream, const char *shost)</td></tr>
<tr class="memdesc:gad3f858951323a44d4ce0525d58b6b442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this stream to capture all packets with matching source hostname.  <a href="#gad3f858951323a44d4ce0525d58b6b442">More...</a><br/></td></tr>
<tr class="separator:gad3f858951323a44d4ce0525d58b6b442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f158c98ef8c4a20e45814bfb1a1fde7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga0f158c98ef8c4a20e45814bfb1a1fde7">sc_stream_ip_source_port</a> (struct sc_stream *stream, const char *sport)</td></tr>
<tr class="memdesc:ga0f158c98ef8c4a20e45814bfb1a1fde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this stream to capture all packets with matching source port.  <a href="#ga0f158c98ef8c4a20e45814bfb1a1fde7">More...</a><br/></td></tr>
<tr class="separator:ga0f158c98ef8c4a20e45814bfb1a1fde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67930eefc09c804a0a197bcd5933c3e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga67930eefc09c804a0a197bcd5933c3e7">sc_stream_ip_protocol</a> (struct sc_stream *stream, int protocol)</td></tr>
<tr class="memdesc:ga67930eefc09c804a0a197bcd5933c3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this stream to capture all packets with matching IP protocol.  <a href="#ga67930eefc09c804a0a197bcd5933c3e7">More...</a><br/></td></tr>
<tr class="separator:ga67930eefc09c804a0a197bcd5933c3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a0155a66123cff377d48e4d63bbe28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga70a0155a66123cff377d48e4d63bbe28">sc_thread_alloc</a> (struct sc_thread **thread_out, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, struct sc_session *scs)</td></tr>
<tr class="memdesc:ga70a0155a66123cff377d48e4d63bbe28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a SolarCapture thread.  <a href="#ga70a0155a66123cff377d48e4d63bbe28">More...</a><br/></td></tr>
<tr class="separator:ga70a0155a66123cff377d48e4d63bbe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5655f2a701e5c5683f209370345cd36a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5655f2a701e5c5683f209370345cd36a"></a>
struct sc_session *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga5655f2a701e5c5683f209370345cd36a">sc_thread_get_session</a> (const struct sc_thread *thread)</td></tr>
<tr class="memdesc:ga5655f2a701e5c5683f209370345cd36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the session associated with a thread. <br/></td></tr>
<tr class="separator:ga5655f2a701e5c5683f209370345cd36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47edbb02fa9f4c20ea621c4d1889ef52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga47edbb02fa9f4c20ea621c4d1889ef52">sc_thread_get_time</a> (const struct sc_thread *thread, struct timespec *time_out)</td></tr>
<tr class="memdesc:ga47edbb02fa9f4c20ea621c4d1889ef52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a thread's "current time".  <a href="#ga47edbb02fa9f4c20ea621c4d1889ef52">More...</a><br/></td></tr>
<tr class="separator:ga47edbb02fa9f4c20ea621c4d1889ef52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7b6a546594c50502c5727916b0f1dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga8c7b6a546594c50502c5727916b0f1dd">sc_thread_calloc</a> (struct sc_thread *thread, size_t bytes)</td></tr>
<tr class="memdesc:ga8c7b6a546594c50502c5727916b0f1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory to be used by a thread.  <a href="#ga8c7b6a546594c50502c5727916b0f1dd">More...</a><br/></td></tr>
<tr class="separator:ga8c7b6a546594c50502c5727916b0f1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fc4a1b23bc0ef3c6289f3e6a6069384"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga3fc4a1b23bc0ef3c6289f3e6a6069384">sc_thread_calloc_aligned</a> (struct sc_thread *thread, size_t bytes, int align)</td></tr>
<tr class="memdesc:ga3fc4a1b23bc0ef3c6289f3e6a6069384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory to be used by a thread.  <a href="#ga3fc4a1b23bc0ef3c6289f3e6a6069384">More...</a><br/></td></tr>
<tr class="separator:ga3fc4a1b23bc0ef3c6289f3e6a6069384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fd26dc0e2b9363480ff1a25b9138787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga1fd26dc0e2b9363480ff1a25b9138787">sc_thread_mfree</a> (struct sc_thread *thread, void *mem)</td></tr>
<tr class="memdesc:ga1fd26dc0e2b9363480ff1a25b9138787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory.  <a href="#ga1fd26dc0e2b9363480ff1a25b9138787">More...</a><br/></td></tr>
<tr class="separator:ga1fd26dc0e2b9363480ff1a25b9138787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c65e8c246b8379a0b688d7e535eeb63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga5c65e8c246b8379a0b688d7e535eeb63">sc_thread_poll</a> (struct sc_thread *thread)</td></tr>
<tr class="memdesc:ga5c65e8c246b8379a0b688d7e535eeb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll a thread.  <a href="#ga5c65e8c246b8379a0b688d7e535eeb63">More...</a><br/></td></tr>
<tr class="separator:ga5c65e8c246b8379a0b688d7e535eeb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b86d78ef588c9513e52f7eb6ca14370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga7b86d78ef588c9513e52f7eb6ca14370">sc_timer_expire_at</a> (struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *cb, const struct timespec *time)</td></tr>
<tr class="memdesc:ga7b86d78ef588c9513e52f7eb6ca14370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a callback at a given time.  <a href="#ga7b86d78ef588c9513e52f7eb6ca14370">More...</a><br/></td></tr>
<tr class="separator:ga7b86d78ef588c9513e52f7eb6ca14370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13794a8b3ef6bce53ad9f5e00c0afa06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga13794a8b3ef6bce53ad9f5e00c0afa06">sc_timer_expire_after_ns</a> (struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *cb, int64_t delta_ns)</td></tr>
<tr class="memdesc:ga13794a8b3ef6bce53ad9f5e00c0afa06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a callback in the future.  <a href="#ga13794a8b3ef6bce53ad9f5e00c0afa06">More...</a><br/></td></tr>
<tr class="separator:ga13794a8b3ef6bce53ad9f5e00c0afa06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7722a172bf7b66915c3835367dd05580"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga7722a172bf7b66915c3835367dd05580">sc_timer_push_back_ns</a> (struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *cb, int64_t delta_ns)</td></tr>
<tr class="memdesc:ga7722a172bf7b66915c3835367dd05580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the expiry time further into the future.  <a href="#ga7722a172bf7b66915c3835367dd05580">More...</a><br/></td></tr>
<tr class="separator:ga7722a172bf7b66915c3835367dd05580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12fcd6ecf711f40c0d9fff65e8b3b6d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga12fcd6ecf711f40c0d9fff65e8b3b6d7">sc_timer_get_expiry_time</a> (const struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *cb, struct timespec *ts_out)</td></tr>
<tr class="memdesc:ga12fcd6ecf711f40c0d9fff65e8b3b6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expiry time of a timer callback.  <a href="#ga12fcd6ecf711f40c0d9fff65e8b3b6d7">More...</a><br/></td></tr>
<tr class="separator:ga12fcd6ecf711f40c0d9fff65e8b3b6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa59c9313b81184570c3d4b853c2b0ac"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gafa59c9313b81184570c3d4b853c2b0ac">sc_ns_from_ts</a> (const struct timespec *ts)</td></tr>
<tr class="memdesc:gafa59c9313b81184570c3d4b853c2b0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a timespec struct to nanoseconds.  <a href="#gafa59c9313b81184570c3d4b853c2b0ac">More...</a><br/></td></tr>
<tr class="separator:gafa59c9313b81184570c3d4b853c2b0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac387bbd504137d73a3be79d2fc0d0f5a"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gac387bbd504137d73a3be79d2fc0d0f5a">sc_ns_from_tv</a> (const struct timeval *tv)</td></tr>
<tr class="memdesc:gac387bbd504137d73a3be79d2fc0d0f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a timeval struct to nanoseconds.  <a href="#gac387bbd504137d73a3be79d2fc0d0f5a">More...</a><br/></td></tr>
<tr class="separator:gac387bbd504137d73a3be79d2fc0d0f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf81a2fdc8da8b7d856376d134ac956b"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gadf81a2fdc8da8b7d856376d134ac956b">sc_ns_from_ms</a> (uint64_t ms)</td></tr>
<tr class="memdesc:gadf81a2fdc8da8b7d856376d134ac956b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert milliseconds to nanoseconds.  <a href="#gadf81a2fdc8da8b7d856376d134ac956b">More...</a><br/></td></tr>
<tr class="separator:gadf81a2fdc8da8b7d856376d134ac956b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9b5615c46ce721e564d384ff9521c4"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gafd9b5615c46ce721e564d384ff9521c4">sc_ns_from_us</a> (uint64_t us)</td></tr>
<tr class="memdesc:gafd9b5615c46ce721e564d384ff9521c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert microseconds to nanoseconds.  <a href="#gafd9b5615c46ce721e564d384ff9521c4">More...</a><br/></td></tr>
<tr class="separator:gafd9b5615c46ce721e564d384ff9521c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1843e2bb992926d68abf9098db8ac0a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga1843e2bb992926d68abf9098db8ac0a5">sc_vi_alloc</a> (struct <a class="el" href="group__scapi.html#structsc__vi">sc_vi</a> **vi_out, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, struct sc_thread *thread, const char *interface)</td></tr>
<tr class="memdesc:ga1843e2bb992926d68abf9098db8ac0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a VI instance.  <a href="#ga1843e2bb992926d68abf9098db8ac0a5">More...</a><br/></td></tr>
<tr class="separator:ga1843e2bb992926d68abf9098db8ac0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2a9c5b65648bc1c09016f1fdfda57ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaa2a9c5b65648bc1c09016f1fdfda57ec">sc_vi_set_recv_node</a> (struct <a class="el" href="group__scapi.html#structsc__vi">sc_vi</a> *vi, struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *name_opt)</td></tr>
<tr class="memdesc:gaa2a9c5b65648bc1c09016f1fdfda57ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node a VI should deliver its received packets to.  <a href="#gaa2a9c5b65648bc1c09016f1fdfda57ec">More...</a><br/></td></tr>
<tr class="separator:gaa2a9c5b65648bc1c09016f1fdfda57ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4f28a80824dc498d43b040e6c089e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga5b4f28a80824dc498d43b040e6c089e5">sc_vi_add_stream</a> (struct <a class="el" href="group__scapi.html#structsc__vi">sc_vi</a> *vi, struct sc_stream *stream)</td></tr>
<tr class="memdesc:ga5b4f28a80824dc498d43b040e6c089e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct a packet stream to a VI.  <a href="#ga5b4f28a80824dc498d43b040e6c089e5">More...</a><br/></td></tr>
<tr class="separator:ga5b4f28a80824dc498d43b040e6c089e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331ad371d93a2070456e4dbbd2727b1c"><td class="memItemLeft" align="right" valign="top">struct sc_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga331ad371d93a2070456e4dbbd2727b1c">sc_vi_get_thread</a> (const struct <a class="el" href="group__scapi.html#structsc__vi">sc_vi</a> *vi)</td></tr>
<tr class="memdesc:ga331ad371d93a2070456e4dbbd2727b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread associated with a VI.  <a href="#ga331ad371d93a2070456e4dbbd2727b1c">More...</a><br/></td></tr>
<tr class="separator:ga331ad371d93a2070456e4dbbd2727b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818e3afd422fbde9d86239cf167e73d8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga818e3afd422fbde9d86239cf167e73d8">sc_vi_get_interface_name</a> (const struct <a class="el" href="group__scapi.html#structsc__vi">sc_vi</a> *vi)</td></tr>
<tr class="memdesc:ga818e3afd422fbde9d86239cf167e73d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the network interface associated with a VI.  <a href="#ga818e3afd422fbde9d86239cf167e73d8">More...</a><br/></td></tr>
<tr class="separator:ga818e3afd422fbde9d86239cf167e73d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d24a4ec17529a249d8fda7084c3a4ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga9d24a4ec17529a249d8fda7084c3a4ab">sc_vi_group_alloc</a> (struct sc_vi_group **vi_out, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, struct sc_session *session, const char *interface, int num_vis)</td></tr>
<tr class="memdesc:ga9d24a4ec17529a249d8fda7084c3a4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a VI group.  <a href="#ga9d24a4ec17529a249d8fda7084c3a4ab">More...</a><br/></td></tr>
<tr class="separator:ga9d24a4ec17529a249d8fda7084c3a4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c65ba3781ef9d4333806bbd54a2eb7"><td class="memItemLeft" align="right" valign="top">struct sc_session *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga82c65ba3781ef9d4333806bbd54a2eb7">sc_vi_group_get_session</a> (const struct sc_vi_group *vi_group)</td></tr>
<tr class="memdesc:ga82c65ba3781ef9d4333806bbd54a2eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the session associated with a VI group.  <a href="#ga82c65ba3781ef9d4333806bbd54a2eb7">More...</a><br/></td></tr>
<tr class="separator:ga82c65ba3781ef9d4333806bbd54a2eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa12972dbe919f4f6dae988c54d81dca3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#gaa12972dbe919f4f6dae988c54d81dca3">sc_vi_alloc_from_group</a> (struct <a class="el" href="group__scapi.html#structsc__vi">sc_vi</a> **vi_out, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, struct sc_thread *thread, struct sc_vi_group *vi_group)</td></tr>
<tr class="memdesc:gaa12972dbe919f4f6dae988c54d81dca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a VI instance from a VI group.  <a href="#gaa12972dbe919f4f6dae988c54d81dca3">More...</a><br/></td></tr>
<tr class="separator:gaa12972dbe919f4f6dae988c54d81dca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cab35bb167da9f925e6e4bb312ca1ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scapi.html#ga7cab35bb167da9f925e6e4bb312ca1ed">sc_vi_group_add_stream</a> (struct sc_vi_group *vi_group, struct sc_stream *stream)</td></tr>
<tr class="memdesc:ga7cab35bb167da9f925e6e4bb312ca1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct a packet stream to a group of VIs.  <a href="#ga7cab35bb167da9f925e6e4bb312ca1ed">More...</a><br/></td></tr>
<tr class="separator:ga7cab35bb167da9f925e6e4bb312ca1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structsc__arg" id="structsc__arg"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_arg</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Representation of an argument. Used by node init functions. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a6677bae25ea564bd366ae22e3e4e6f08"></a>const char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
<p>Parameter name </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a46cda645b8c05981961b18126dee7d61"></a>enum <a class="el" href="group__scapi.html#ga0fbf06fdd6b6fea5987db9f1925a6003">sc_param_type</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
<p>Parameter type </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a9846de1135accb190dc7c55b847447c8"></a>union <a class="el" href="group__scapi.html#unionsc__arg_8val">sc_arg</a></td>
<td class="fieldname">
val</td>
<td class="fielddoc">
<p>Parameter value </p>
</td></tr>
</table>

</div>
</div>
<a name="unionsc__arg_8val" id="unionsc__arg_8val"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union sc_arg.val</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a365b8373d0bf6dc9e3450af670cc1d35"></a>double</td>
<td class="fieldname">
dbl</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a865c0c0b4ab0e063e5caa3387c1a8741"></a>int64_t</td>
<td class="fieldname">
i</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abe8f80182e0c983916da7338c2c1c040"></a>struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> *</td>
<td class="fieldname">
obj</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a341be97d9aff90c9978347f66f945b77"></a>const char *</td>
<td class="fieldname">
str</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structsc__dlist" id="structsc__dlist"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_dlist</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Doubly linked list pointers. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3cc1e93ce81d748f8c65a80e0760bab6"></a>struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
<p>A pointer to next item in list (set to itself if it is at the end of the list). </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac81201f3e23a6cf0618a974d25b218e8"></a>struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *</td>
<td class="fieldname">
prev</td>
<td class="fielddoc">
<p>A pointer to previous item in list (set to itself if it is at the start of the list). </p>
</td></tr>
</table>

</div>
</div>
<a name="structsc__callback" id="structsc__callback"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_callback</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A callback object. </p>
<p>Callback objects provide a way to be notified when an event of interest occurs. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a269b9e0333c72f176e1fccaec7a3fe36"></a><a class="el" href="group__scapi.html#ga8cf1e664fe251b17c7bfb3aaa89548ff">sc_callback_handler_fn</a> *</td>
<td class="fieldname">
cb_handler_fn</td>
<td class="fielddoc">
<p>The callback to be called when the event of interest occurs. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac093b34422cf24534b22fe17f5839fac"></a>struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a></td>
<td class="fieldname">
cb_link</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa0cd50a9379f993ac9f25c8496ff9d69"></a>void *</td>
<td class="fieldname">
cb_private</td>
<td class="fielddoc">
<p>Additional state to be passed to the callback function. </p>
</td></tr>
</table>

</div>
</div>
<a name="structsc__node" id="structsc__node"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_node</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Description of a node. </p>
<p>This is passed to every function used to call into the node. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aba23bed8a00a64831523f8b462b85928"></a>char *</td>
<td class="fieldname">
nd_name</td>
<td class="fielddoc">
<p>Name of the node, set automatically when creating node. <code>nd_name</code> is set to attribute name if this provided, otherwise <a class="el" href="group__scapi.html#af12c7da8165c7463ac11f53ddf04cb6b">sc_node_factory.nf_name</a> with a unique node instance number appended </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a948cc4ceb62af844c5ce7135e4a882d2"></a>void *</td>
<td class="fieldname">
nd_private</td>
<td class="fielddoc">
<p>Set by node for local state </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a50629fbc188ebb5984cc9e48c0183377"></a>const struct <a class="el" href="group__scapi.html#structsc__node__type">sc_node_type</a> *</td>
<td class="fieldname">
nd_type</td>
<td class="fielddoc">
<p>Type of node, set automatically on creation of the node </p>
</td></tr>
</table>

</div>
</div>
<a name="structsc__node__link" id="structsc__node__link"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_node_link</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Description of a link the node has. </p>
<p>This is passed to the node initialisation function </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0d576a8919cba70b2369798f6fd5f02e"></a>const char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
<p>Set when a link is added to the node </p>
</td></tr>
</table>

</div>
</div>
<a name="structsc__node__factory" id="structsc__node__factory"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_node_factory</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Struct to hold information about how to create an instance of this node. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad3b138e5c6aa54dd401ec1f3f6d9dd20"></a><a class="el" href="group__scapi.html#gaec792135358df254bea89bb9dd6a2a09">sc_node_init_fn</a> *</td>
<td class="fieldname">
nf_init_fn</td>
<td class="fielddoc">
<p>The function to call to initialise the node </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af12c7da8165c7463ac11f53ddf04cb6b"></a>const char *</td>
<td class="fieldname">
nf_name</td>
<td class="fielddoc">
<p>The name of the node. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aed298c8c1f00d202a301f6f663cc074f"></a>int</td>
<td class="fieldname">
nf_node_api_ver</td>
<td class="fielddoc">
<p>The version of solar_capture this node is designed for. The most recent version is stored in the macro SC_API_VER. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2555c268f4a9f555e09608aa893873ed"></a>void *</td>
<td class="fieldname">
nf_private</td>
<td class="fielddoc">
<p>For use as local state by the node sc_node_init_fn function only. This will not be passed to other node functions </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a082fd403ccf4a6f20a0ae1214c45fea4"></a>void *</td>
<td class="fieldname">
nf_reserved[8]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a30f018828ad4aecd92be0b9561b22ddd"></a>const char *</td>
<td class="fieldname">
nf_source_file</td>
<td class="fielddoc">
<p>The filename of the source file for this node. Use the <b>FILE</b> macro to set this. </p>
</td></tr>
</table>

</div>
</div>
<a name="structsc__node__type" id="structsc__node__type"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_node_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Describes a type of node. </p>
<p>This struct describes what functions are responsible for the behaviour of the node. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7628877fd154e83de08229ed43a1d85b"></a><a class="el" href="group__scapi.html#ga1746848cc14ace3891999a360bc8d48a">sc_node_add_link_fn</a> *</td>
<td class="fieldname">
nt_add_link_fn</td>
<td class="fielddoc">
<p>(Optional) Function to call when a node tries to establish a link from this node, set to NULL if not required. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae1d35c2a848b45637015ebdebd5c1e30"></a><a class="el" href="group__scapi.html#gadcdef5088baa04ac5bf37fcf5a90cd0e">sc_node_end_of_stream_fn</a> *</td>
<td class="fieldname">
nt_end_of_stream_fn</td>
<td class="fielddoc">
<p>(Optional) Function to call when nodes upstream indicate end of stream, set to NULL if not required. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad6e1366a470908a80c05ec2e1a5a6349"></a>const char *</td>
<td class="fieldname">
nt_name</td>
<td class="fielddoc">
<p>Name of the node (set automatically by sc_node_type_alloc using <a class="el" href="group__scapi.html#af12c7da8165c7463ac11f53ddf04cb6b">sc_node_factory.nf_name</a>. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a46ee950e6a380b0c40a63295723c32c2"></a><a class="el" href="group__scapi.html#ga30a15ad23a4ff1bc74d489e61a187ec9">sc_node_pkts_fn</a> *</td>
<td class="fieldname">
nt_pkts_fn</td>
<td class="fielddoc">
<p>Function to call when the node receives packets. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a489e5bd4f4c7428e106f32a197ce6fb5"></a><a class="el" href="group__scapi.html#ga4be5c52459c32aba638861f7d775b223">sc_node_prep_fn</a> *</td>
<td class="fieldname">
nt_prep_fn</td>
<td class="fielddoc">
<p>Function to call to prepare the node after the node graph is finalised. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="acc4ca740c98b0d4689cbb42d3ec1e684"></a>void *</td>
<td class="fieldname">
nt_private</td>
<td class="fielddoc">
<p>Additional state for the node. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad4c996aa3b2284357af11211cb17cef9"></a><a class="el" href="group__scapi.html#gad856a763cba38bb2c58a8fd7ec5a866c">sc_node_select_subnode_fn</a> *</td>
<td class="fieldname">
nt_select_subnode_fn</td>
<td class="fielddoc">
<p>(Optional) Function to call when another node tries to establish a link to this node, set to NULL if not required. </p>
</td></tr>
</table>

</div>
</div>
<a name="structsc__packet" id="structsc__packet"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_packet</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Representation of a packet. </p>
<p>This data-structure describes a packet. It includes pointers to the packet contents, meta-data relating to the packet and fields to support creating lists of packets.</p>
<p>Each <a class="el" href="group__scapi.html#structsc__packet" title="Representation of a packet. ">sc_packet</a> instance is usually associated with a buffer that holds the packet contents. A packet may span multiple such buffers, in which case the 'head' buffer uses <code>frags</code> and <code>frags_tail</code> to identify the remaining buffers (which are linked via the <code>next</code> field). Nodes should generally not use the <code>frags</code>, <code>frags_n</code> and <code>frags_tail</code> fields, because they are sometimes used in special ways. Instead nodes should use <code>iov</code> and <code>iovlen</code> to find the buffer(s) underlying an <a class="el" href="group__scapi.html#structsc__packet" title="Representation of a packet. ">sc_packet</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0764f4fab658f994793f89fa51742937"></a>uint16_t</td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
<p>flags defined below </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8775922d88ab9a41214c2208ac3e5bce"></a>struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *</td>
<td class="fieldname">
frags</td>
<td class="fielddoc">
<p>list of chained fragments </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8e846983fb888e76e6fbf26062a4a159"></a>uint8_t</td>
<td class="fieldname">
frags_n</td>
<td class="fielddoc">
<p>number of fragments in <code>frags</code> chain </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa75cd1d4b5f1eb441469f2c615100b01"></a>struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> **</td>
<td class="fieldname">
frags_tail</td>
<td class="fielddoc">
<p>last fragment in chain </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aae5c3741cf9dc13a215856b6186a5273"></a>uint16_t</td>
<td class="fieldname">
frame_len</td>
<td class="fielddoc">
<p>original frame length in bytes </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ade08fdca59e3e1bd8699679c922ec053"></a>struct iovec *</td>
<td class="fieldname">
iov</td>
<td class="fielddoc">
<p>identifies packet data </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8f1cb64be38b15d855b8d9d1017f189f"></a>uint8_t</td>
<td class="fieldname">
iovlen</td>
<td class="fielddoc">
<p>number of entries in <code>iov</code> array </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1347f421b7f8c62ed3914d9c1bba5192"></a>uintptr_t *</td>
<td class="fieldname">
metadata</td>
<td class="fielddoc">
<p>packet metadata </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab50c95d9ed6b79e95a01073efb560e99"></a>struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
<p>next packet in a packet list </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a5573dbee1ace1c0376edab39c7ba71d4"></a>uint16_t</td>
<td class="fieldname">
reserved1</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a664c91ac6bfaf60a852c5c6bc788b322"></a>uint32_t</td>
<td class="fieldname">
reserved2</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab7891e1fd4f53041fd47a40fd93dc5f7"></a>uint32_t</td>
<td class="fieldname">
ts_nsec</td>
<td class="fielddoc">
<p>timestamp (nanoseconds) </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abbe48151472b625064ca5c03a2aade9a"></a>uint64_t</td>
<td class="fieldname">
ts_sec</td>
<td class="fielddoc">
<p>timestamp (seconds) </p>
</td></tr>
</table>

</div>
</div>
<a name="structsc__packet__list" id="structsc__packet__list"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_packet_list</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A list of packets or packet buffers. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac2a4ff4a7ec7704c846e4f83c69b6627"></a>struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *</td>
<td class="fieldname">
head</td>
<td class="fielddoc">
<p>Head of list </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a426c4a6c7920c23eddab76f94cf86a42"></a>int</td>
<td class="fieldname">
num_frags</td>
<td class="fielddoc">
<p>Number of pkt frags in the list </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3f7b8ae9fe79eb640ec1bafba9d06cc6"></a>int</td>
<td class="fieldname">
num_pkts</td>
<td class="fielddoc">
<p>Number of pkts in the list </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a22c6154b53fa34cc81840067ca8eb3cb"></a>struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> **</td>
<td class="fieldname">
tail</td>
<td class="fielddoc">
<p>Ptr to next field in tail of list </p>
</td></tr>
</table>

</div>
</div>
<a name="structsc__iovec__ptr" id="structsc__iovec__ptr"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_iovec_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>An <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> provides a convenient way to iterate over an iovec array without modifying it. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="adf604417c8a48cda52fdef4aa6660c77"></a>struct iovec</td>
<td class="fieldname">
io</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="afe019ec0b72173a32955de43998cd6df"></a>const struct iovec *</td>
<td class="fieldname">
iov</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0a0b4dcf5f5e32d86a4d58bfe4c79f10"></a>int</td>
<td class="fieldname">
iovlen</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structsc__pkt__predicate" id="structsc__pkt__predicate"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_pkt_predicate</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A packet predicate object. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a9adcc4f31b4dc10f821d8d13974207de"></a>void *</td>
<td class="fieldname">
pred_private</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab7af184e6cd91ec8a24fea8360ad21c6"></a>sc_pkt_predicate_test_fn *</td>
<td class="fieldname">
pred_test_fn</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structsc__session__error" id="structsc__session__error"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_session_error</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A SolarCapture session error object returned by <a class="el" href="group__scapi.html#gaa2ed816358bceda7232241aec4a56fc2" title="Returns an error from a SolarCapture session. ">sc_session_error_get</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a4624cd13a2e9f79f9044c084afa68807"></a>int</td>
<td class="fieldname">
err_errno</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad34e00582c6d0af7b19b4a6b02fd119e"></a>char *</td>
<td class="fieldname">
err_file</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a764bebc611b01254dd81e87d0efa088d"></a>char *</td>
<td class="fieldname">
err_func</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab8e31cd074a9b9b7e5beea195d6f7e21"></a>int</td>
<td class="fieldname">
err_line</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2e86e2b21917f09f160670ce83293f42"></a>char *</td>
<td class="fieldname">
err_msg</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structsc__attr" id="structsc__attr"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_attr</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Attribute object. </p>
<p>Attributes are used to specify optional behaviours and parameters, usually when allocating other SolarCapture objects. Each attribute object defines a complete set of the attributes that SolarCapture understands.</p>
<p>For example, the "affinity_core" attribute controls which CPU core an sc_thread runs on.</p>
<p>The default values for attributes may be overridden by setting the environment variable SC_ATTR. For example:</p>
<p>SC_ATTR="log_level=3;snap=2"</p>
<p>Each function that takes an attribute argument will only be interested in a subset of the attributes specified by an <a class="el" href="group__scapi.html#structsc__attr" title="Attribute object. ">sc_attr</a> instance. Other attributes are ignored.</p>
<p>The set of attributes supported by SolarCapture may change between releases, so applications should where possible tolerate failures when setting attributes. </p>
</div>
</div>
</div>
<a name="structsc__object" id="structsc__object"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_object</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a>, <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a81f048052c4a067d1d53144de606cf2b">SC_PARAM_DBL</a> and <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> respectively for these) to nodes. </p>
</div>
</div>
</div>
<a name="structsc__vi" id="structsc__vi"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_vi</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A VI object. </p>
</div>
</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga576987c4c7e5cfff5565568168ccf32b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SC_ARG_DBL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;{ .name = _name, .type = <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a81f048052c4a067d1d53144de606cf2b">SC_PARAM_DBL</a>, .val.dbl = _val }</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to construct a <a class="el" href="group__scapi.html#structsc__arg" title="Representation of an argument. Used by node init functions. ">sc_arg</a> struct of type <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a81f048052c4a067d1d53144de606cf2b">SC_PARAM_DBL</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>Name of argument. </td></tr>
    <tr><td class="paramname">_val</td><td>Value of argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1db82ea8e9e2b3e0c226e4da5911cab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SC_ARG_INT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;{ .name = _name, .type = <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a>, .val.i = _val }</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to construct a <a class="el" href="group__scapi.html#structsc__arg" title="Representation of an argument. Used by node init functions. ">sc_arg</a> struct of type <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>Name of argument. </td></tr>
    <tr><td class="paramname">_val</td><td>Value of argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2971ec30636efc68f77de53ded68aa40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SC_ARG_OBJ</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;{ .name = _name, .type = <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a582ef31fdf6cc8bdbd1153cb2afc560b">SC_PARAM_OBJ</a>, .val.obj = _val }</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to construct a <a class="el" href="group__scapi.html#structsc__arg" title="Representation of an argument. Used by node init functions. ">sc_arg</a> struct of type <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a582ef31fdf6cc8bdbd1153cb2afc560b">SC_PARAM_OBJ</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>Name of argument. </td></tr>
    <tr><td class="paramname">_val</td><td>Value of argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa3d8599771d57cf1700f84faf6ab21cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SC_ARG_STR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;{ .name = _name, .type = <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a>, .val.str = _val }</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to construct a <a class="el" href="group__scapi.html#structsc__arg" title="Representation of an argument. Used by node init functions. ">sc_arg</a> struct of type <a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>Name of argument. </td></tr>
    <tr><td class="paramname">_val</td><td>Value of argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3152057b96aae8e524716cf30bc166c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SC_CONTAINER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mbr_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_mbr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;( (c_type*) ((char*)(p_mbr) - <a class="el" href="group__scapi.html#ga082426dca3734e1a84e51424a8a0a012">SC_MEMBER_OFFSET</a>(c_type, mbr_name)) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a pointer to the outer container of a given <a class="el" href="group__scapi.html#structsc__dlist" title="Doubly linked list pointers. ">sc_dlist</a> pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c_type</td><td>The container type. </td></tr>
    <tr><td class="paramname">mbr_name</td><td>The name of the field in the container holding the <a class="el" href="group__scapi.html#structsc__dlist" title="Doubly linked list pointers. ">sc_dlist</a> member. </td></tr>
    <tr><td class="paramname">p_mbr</td><td>A pointer to the <a class="el" href="group__scapi.html#structsc__dlist" title="Doubly linked list pointers. ">sc_dlist</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8034044fe316eae0804c49db256df481"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SC_DLIST_FOR_EACH_OBJ</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iter, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mbr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span>( (iter) = <a class="code" href="group__scapi.html#ga3152057b96aae8e524716cf30bc166c1">SC_CONTAINER</a>(typeof(*(iter)), mbr, (list)-&gt;next);       \</div>
<div class="line">       &amp;(iter)-&gt;mbr != (list);                                          \</div>
<div class="line">       (iter) = <a class="code" href="group__scapi.html#ga3152057b96aae8e524716cf30bc166c1">SC_CONTAINER</a>(typeof(*(iter)), mbr, (iter)-&gt;mbr.next) )</div>
<div class="ttc" id="group__scapi_html_ga3152057b96aae8e524716cf30bc166c1"><div class="ttname"><a href="group__scapi.html#ga3152057b96aae8e524716cf30bc166c1">SC_CONTAINER</a></div><div class="ttdeci">#define SC_CONTAINER(c_type, mbr_name, p_mbr)</div><div class="ttdoc">Fetch a pointer to the outer container of a given sc_dlist pointer. </div><div class="ttdef"><b>Definition:</b> dlist.h:71</div></div>
</div><!-- fragment -->
<p>Create a for statement that loops over each container item in the list. It is not safe to modify the list using this macro, if list modifications are required see <a class="el" href="group__scapi.html#gaa2e795d924234a1e1415d55021b82ad8" title="Create a for statement that loops over each container item in the list which can be safely be modifie...">SC_DLIST_FOR_EACH_OBJ_SAFE</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A pointer to the head of the <a class="el" href="group__scapi.html#structsc__dlist" title="Doubly linked list pointers. ">sc_dlist</a>. </td></tr>
    <tr><td class="paramname">iter</td><td>A pointer of the same type as the container. </td></tr>
    <tr><td class="paramname">mbr</td><td>The name of the field in the container containing the <a class="el" href="group__scapi.html#structsc__dlist" title="Doubly linked list pointers. ">sc_dlist</a> struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa2e795d924234a1e1415d55021b82ad8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SC_DLIST_FOR_EACH_OBJ_SAFE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iter, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">next_entry, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mbr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span>( (iter) = <a class="code" href="group__scapi.html#ga3152057b96aae8e524716cf30bc166c1">SC_CONTAINER</a>(typeof(*(iter)), mbr, (list)-&gt;next),            \</div>
<div class="line">       (next_entry) = <a class="code" href="group__scapi.html#ga3152057b96aae8e524716cf30bc166c1">SC_CONTAINER</a>(typeof(*(iter)), mbr, (iter)-&gt;mbr.next);  \</div>
<div class="line">       &amp;(iter)-&gt;mbr != (list);                                               \</div>
<div class="line">       (iter) = (next_entry),                                                \</div>
<div class="line">       (next_entry) = <a class="code" href="group__scapi.html#ga3152057b96aae8e524716cf30bc166c1">SC_CONTAINER</a>(typeof(*(iter)), mbr, (iter)-&gt;mbr.next) )</div>
<div class="ttc" id="group__scapi_html_ga3152057b96aae8e524716cf30bc166c1"><div class="ttname"><a href="group__scapi.html#ga3152057b96aae8e524716cf30bc166c1">SC_CONTAINER</a></div><div class="ttdeci">#define SC_CONTAINER(c_type, mbr_name, p_mbr)</div><div class="ttdoc">Fetch a pointer to the outer container of a given sc_dlist pointer. </div><div class="ttdef"><b>Definition:</b> dlist.h:71</div></div>
</div><!-- fragment -->
<p>Create a for statement that loops over each container item in the list which can be safely be modified during traversal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A pointer to the head of the <a class="el" href="group__scapi.html#structsc__dlist" title="Doubly linked list pointers. ">sc_dlist</a>. </td></tr>
    <tr><td class="paramname">iter</td><td>A pointer of the same type as the container. </td></tr>
    <tr><td class="paramname">next_entry</td><td>A pointer of the same type as the container. </td></tr>
    <tr><td class="paramname">mbr</td><td>The name of the field in the container containing the <a class="el" href="group__scapi.html#structsc__dlist" title="Doubly linked list pointers. ">sc_dlist</a> struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga082426dca3734e1a84e51424a8a0a012"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SC_MEMBER_OFFSET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mbr_name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((uint32_t) (uintptr_t)(&amp;((c_type*)0)-&gt;mbr_name))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate memory offset of a field within a struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c_type</td><td>The struct type. </td></tr>
    <tr><td class="paramname">mbr_name</td><td>The field name to calculate the offset of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8e99f50e4d3eaccea8700ab02f56a581"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SC_MEMBER_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mbr_name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(sizeof(((c_type*)0)-&gt;mbr_name))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the size of a field within a struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c_type</td><td>The struct type. </td></tr>
    <tr><td class="paramname">mbr_name</td><td>The field to calculate the size of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8ea22a86b4ebe75ab2d4c0ed555c551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sc_node_fwd_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rc&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;__sc_node_fwd_error((node), __FILE__, __LINE__, __func__, (rc))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward error from a failed sc call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node that forwards the error </td></tr>
    <tr><td class="paramname">rc</td><td>The error code returned by the sc call</td></tr>
  </table>
  </dd>
</dl>
<p>Call this function to propagate an error generated by SolarCapture. </p>

</div>
</div>
<a class="anchor" id="gafac01197f593310d5792375fd1bf10ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sc_node_set_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">errno_code, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">__sc_node_set_error((node), __FILE__, __LINE__, __func__,     \</div>
<div class="line">                      (errno_code), __VA_ARGS__)</div>
</div><!-- fragment -->
<p>Set error from within the implementation of a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node that originates the error </td></tr>
    <tr><td class="paramname">errno_code</td><td>An error code from errno.h (or can be zero)</td></tr>
  </table>
  </dd>
</dl>
<p>Call this function when returning an error to SolarCapture from a node. The value returned by this function should be passed on to the caller of the function reporting the error. </p>

</div>
</div>
<a class="anchor" id="ga357de7af8618e5b26ed52e01c0158508"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ST_CONSTANT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;enum { name = val };a</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant value in the template definition. </p>
<p>After the node has initialised its shared data structures <code>name</code> will be used as the field in the stats struct to update this data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The field name. </td></tr>
    <tr><td class="paramname">val</td><td>The constant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5fefab940214b246feaafded5776dc63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ST_FIELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">kind&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;type name;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A C basic type field in the template definition. </p>
<p>After the node has initialised its shared data structures <code>name</code> will be used as the field in the stats struct to update this data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The basic data type. </td></tr>
    <tr><td class="paramname">name</td><td>The field name. </td></tr>
    <tr><td class="paramname">kind</td><td>A string to describe the kind of data. Examples used by SolarCapture nodes are pkt_count, ev_count, config, const, magnitude. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga558f37e5def5f1639a6780d3b6d089ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ST_FIELD_STR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">kind&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;char name[len];</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A string field in the template definition. </p>
<p>After the node has initialised its shared data structures <code>name</code> will be used as the field in the stats struct to update this data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The field name. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the string. </td></tr>
    <tr><td class="paramname">kind</td><td>A string to describe the kind of data. Examples used by SolarCapture nodes are pkt_count, ev_count, config, const, magnitude. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga140c90f6225c3044aa11493432cde1e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ST_STRUCT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;struct name {</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start of the template definition. </p>
<p>After the node has initialised its shared data structures the resulting struct type for updating the stats will use <code>name</code> for its type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the template. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga8cf1e664fe251b17c7bfb3aaa89548ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( sc_callback_handler_fn)(struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *, void *event_info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback handler function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback struct registered with this callback. </td></tr>
    <tr><td class="paramname">event_info</td><td>If callback was registered using <a class="el" href="group__scapi.html#ga6c57918e0012ba6fd32371c4db862913" title="Request a callback when the thread is idle. ">sc_epoll_ctl</a> this will contain the uint32_t epoll_events bitmask (see man 2 epoll_ctl) In all other cases this is not used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1746848cc14ace3891999a360bc8d48a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int( sc_node_add_link_fn)(struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *from_node, const char *link_name, struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *to_node, const char *to_name_opt)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature of nt_add_link_fn function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_node</td><td>The node being linked from </td></tr>
    <tr><td class="paramname">link_name</td><td>The name of the link </td></tr>
    <tr><td class="paramname">to_node</td><td>The node being linked to </td></tr>
    <tr><td class="paramname">to_name_opt</td><td>Optional name of ingress link</td></tr>
  </table>
  </dd>
</dl>
<p>This method is optional and supports compound nodes. It is invoked on <code>from_node</code> when <a class="el" href="group__scapi.html#ga25ee0880d5b47c78a5d1b07926f9fb4d" title="Add a link from one node to another. ">sc_node_add_link()</a> is called, and gives the implementation an opportunity to select the subnode(s) to be linked from or issue an error if an attempt is made to create an unwanted link.</p>
<p>The implementation of this function should invoke <a class="el" href="group__scapi.html#ga25ee0880d5b47c78a5d1b07926f9fb4d" title="Add a link from one node to another. ">sc_node_add_link()</a> on <code>from_node</code> or on a subnode, or should return an error. If it returns an error it should do so by calling <a class="el" href="group__scapi.html#gafac01197f593310d5792375fd1bf10ab" title="Set error from within the implementation of a node. ">sc_node_set_error</a> with a suitable error message, and return the value returned by <a class="el" href="group__scapi.html#gafac01197f593310d5792375fd1bf10ab" title="Set error from within the implementation of a node. ">sc_node_set_error</a>.</p>
<p>The <code>to_node</code> and <code>to_name_opt</code> arguments should be passed unmodified. The implementation may invoke <a class="el" href="group__scapi.html#ga25ee0880d5b47c78a5d1b07926f9fb4d" title="Add a link from one node to another. ">sc_node_add_link()</a> multiple times to create links from multiple subnodes. </p>

</div>
</div>
<a class="anchor" id="gadcdef5088baa04ac5bf37fcf5a90cd0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( sc_node_end_of_stream_fn)(struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature of nt_end_of_stream_fn function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node.</td></tr>
  </table>
  </dd>
</dl>
<p>This method is invoked when all incoming upstream nodes have indicated end-of-stream. After this method has been called <a class="el" href="group__scapi.html#ga30a15ad23a4ff1bc74d489e61a187ec9" title="Signature of nt_pkts_fn function. ">sc_node_pkts_fn</a> will not be called again. The implementation of this function may propagate end-of-stream through its outgoing links by calling <a class="el" href="group__scapi.html#ga31a56ca7cf9cb5339613bb8c3414662d" title="Indicate end-of-stream on a link. ">sc_node_link_end_of_stream()</a>. If this function is not provided end-of-stream will not propagate further through the node graph.</p>
<p>After the node has propagated end-of-stream to a node through its outgoing link it should not pass any more packets to this node.</p>
<p>This method is optional. </p>

</div>
</div>
<a class="anchor" id="gaec792135358df254bea89bb9dd6a2a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int( sc_node_init_fn)(struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *attr, const struct <a class="el" href="group__scapi.html#structsc__node__factory">sc_node_factory</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature of function to initialise a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node being initialised </td></tr>
    <tr><td class="paramname">factory</td><td>The node factory </td></tr>
    <tr><td class="paramname">attr</td><td>Attributes used to create the node. Valid only until this function exits. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters passed by user</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to initialise an instance of a node. It will be called before the node graph has been finalised i.e. before all links between nodes have been established at the point when a python API user calls Thread.new_node() or when a C API user calls <a class="el" href="group__scapi.html#ga15eae832e9b93996b7ee5e311c991cf4" title="Allocate a packet processing node. ">sc_node_alloc</a> or <a class="el" href="group__scapi.html#ga7a27a36506cdbb62afcaaeb812ef1b6e" title="Allocate a packet processing node by name. ">sc_node_alloc_named</a>. As much initialisation as possible should be done here, any initialisation that can't be done at this stage (for instance because it requires that the node graph is finalised) can be done later in <a class="el" href="group__scapi.html#ga4be5c52459c32aba638861f7d775b223" title="Signature of nt_prep_fn function. ">sc_node_prep_fn</a>.</p>
<p><code>attr</code> will not remain valid once the init function returns. If you want to use <code>attr</code> after this function exits or use a modified version of <code>attr</code> you should use <a class="el" href="group__scapi.html#ga897456b8bdec9bab4f0f9613fb776e06" title="Duplicate an attribute object. ">sc_attr_dup()</a> to get a persistant writable version. </p>

</div>
</div>
<a class="anchor" id="ga30a15ad23a4ff1bc74d489e61a187ec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( sc_node_pkts_fn)(struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *packet_list)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature of nt_pkts_fn function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node receiving the packets </td></tr>
    <tr><td class="paramname">packet_list</td><td>List of packets</td></tr>
  </table>
  </dd>
</dl>
<p>This function will be called when packets are received on <b>any</b> incoming link to the node. It is not possible to distinguish which incoming link the packets arrived from directly. If the node needs to distinguish between incoming streams then either upstream nodes must append metadata to the packets or the node must be constructed from subnodes with each subnode connected to a subset of incoming links.</p>
<p>Once this function is invoked the node gets ownership of the packets. Ownership is relinquished by invoking <a class="el" href="group__scapi.html#gaf1f892361f4b0bcc985bbf4169be5f80" title="Forward a list of packets. ">sc_forward_list</a> or <a class="el" href="group__scapi.html#gadee3bbd8865a6d15ecb982cfbf11bca0" title="Forward a single packet. ">sc_forward</a> to forward or free the packets. </p>

</div>
</div>
<a class="anchor" id="ga4be5c52459c32aba638861f7d775b223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int( sc_node_prep_fn)(struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a> *const *links, int n_links)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature of nt_prep_fn function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node being prepared </td></tr>
    <tr><td class="paramname">links</td><td>Array of outgoing links the node has </td></tr>
    <tr><td class="paramname">n_links</td><td>Number of outgoing links in the array</td></tr>
  </table>
  </dd>
</dl>
<p>This callback is invoked to prepare <code>node</code> for live packet processing. The implementation typically checks the egress links and saves them to private storage.</p>
<p>Any initialisation that could not be done in sc_node_init should be done here.</p>
<p>If the node needs to create subnodes and establish links it should be done <b>before</b> this stage in one of <a class="el" href="group__scapi.html#gaec792135358df254bea89bb9dd6a2a09" title="Signature of function to initialise a node. ">sc_node_init_fn</a>, <a class="el" href="group__scapi.html#gad856a763cba38bb2c58a8fd7ec5a866c" title="Signature of nt_select_subnode_fn function. ">sc_node_select_subnode_fn</a> or <a class="el" href="group__scapi.html#ga1746848cc14ace3891999a360bc8d48a" title="Signature of nt_add_link_fn function. ">sc_node_add_link_fn</a>.</p>
<p>Note that the array <code>links</code> is only valid for the duration of this function call, but the <a class="el" href="group__scapi.html#structsc__node__link" title="Description of a link the node has. ">sc_node_link</a> objects are valid for at least the lifetime of the node. </p>

</div>
</div>
<a class="anchor" id="gad856a763cba38bb2c58a8fd7ec5a866c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a>*( sc_node_select_subnode_fn)(struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *node, const char *name, char **new_name_out)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature of nt_select_subnode_fn function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node being linked to </td></tr>
    <tr><td class="paramname">name</td><td>The name of the link (may be NULL) </td></tr>
    <tr><td class="paramname">new_name_out</td><td>Use to set a different name for sub-node</td></tr>
  </table>
  </dd>
</dl>
<p>This method is optional and supports compound nodes. It is invoked on <code>node</code> when <a class="el" href="group__scapi.html#ga25ee0880d5b47c78a5d1b07926f9fb4d" title="Add a link from one node to another. ">sc_node_add_link()</a> is called, and gives the implementation an opportunity to select an alternative subnode that should be linked to or issue an error if an attempt is made to create an unwanted link.</p>
<p>The implementation should return <code>node</code> or a subnode, or NULL to indicate that <code>name</code> is not valid for this node.</p>
<p>If a new name is specified via <code>new_name_out</code> then ownership is passed to the caller, and it will be freed with free(). </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga7dbec837a1592a9f6a4bc649ea583f0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__scapi.html#ga7dbec837a1592a9f6a4bc649ea583f0d">sc_object_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of data the <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a> contains. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga7dbec837a1592a9f6a4bc649ea583f0da6cc791f350dc8201235237b69a7c428e"></a>SC_OBJ_OPAQUE</em>&#160;</td><td class="fielddoc">
<p>An opaque pointer </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7dbec837a1592a9f6a4bc649ea583f0dae140bed569231d8aa0df5929f388cb03"></a>SC_OBJ_PKT_PREDICATE</em>&#160;</td><td class="fielddoc">
<p>A packet predicate (see <a class="el" href="group__scapi.html#structsc__pkt__predicate" title="A packet predicate object. ">sc_pkt_predicate</a>) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga0fbf06fdd6b6fea5987db9f1925a6003"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__scapi.html#ga0fbf06fdd6b6fea5987db9f1925a6003">sc_param_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible parameter types that can be used for arguments in a node's init function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80"></a>SC_PARAM_STR</em>&#160;</td><td class="fielddoc">
<p>const char pointer (nul terminated) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab"></a>SC_PARAM_INT</em>&#160;</td><td class="fielddoc">
<p>signed 64 bit int </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0fbf06fdd6b6fea5987db9f1925a6003a582ef31fdf6cc8bdbd1153cb2afc560b"></a>SC_PARAM_OBJ</em>&#160;</td><td class="fielddoc">
<p><a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a> pointer </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0fbf06fdd6b6fea5987db9f1925a6003a81f048052c4a067d1d53144de606cf2b"></a>SC_PARAM_DBL</em>&#160;</td><td class="fielddoc">
<p>native double type </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga2fec54c32ef2624a3b888b0808b1d140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_attr_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> **&#160;</td>
          <td class="paramname"><em>attr_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an attribute object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr_out</td><td>The attribute object is returned here.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fails (returns -1) if the SC_ATTR environment variable is malformed. The SolarCapture error status is not set in this case because attribute objects are not associated with an sc_session. </p>

</div>
</div>
<a class="anchor" id="gaf4c73aa3cae3a0a3d81159c2fdd24472"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_attr_doc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attr_name_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char ***&#160;</td>
          <td class="paramname"><em>docs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>docs_len_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns documentation for attributes. Used by solar_capture_doc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr_name_opt</td><td>The attribute name. </td></tr>
    <tr><td class="paramname">docs_out</td><td>On success, the resulting doc string output. </td></tr>
    <tr><td class="paramname">docs_len_out</td><td>On success, the length of the doc string output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga897456b8bdec9bab4f0f9613fb776e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a>* sc_attr_dup </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate an attribute object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The attribute object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new attribute object.</dd></dl>
<p>This function is useful when you want to make non-destructive changes to an existing attribute object. </p>

</div>
</div>
<a class="anchor" id="ga674f74da55d7a68627725b500be874af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_attr_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an attribute object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The attribute object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3afda524568bd545831ead4b84c78e90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_attr_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return attributes to their default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The attribute object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ac254aeafb436d9dd073b640a622c34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_attr_set_from_str </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an attribute to a string value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The attribute object. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the attribute. </td></tr>
    <tr><td class="paramname">val</td><td>New value for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns an error if <code>name</code> is not a valid attribute name, or if it is not possible to convert <code>val</code> to a valid value for the attribute. </p>

</div>
</div>
<a class="anchor" id="gadd4c5b0938171036d905818462cacdc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_attr_set_int </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an attribute to an integer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The attribute object. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the attribute. </td></tr>
    <tr><td class="paramname">val</td><td>New value for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns an error if <code>name</code> is not a valid attribute name, or if the attribute is not an integer attribute. </p>

</div>
</div>
<a class="anchor" id="gaff50aad127b0dec4b286a7d33e06844f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_attr_set_str </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an attribute to a string value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The attribute object. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the attribute. </td></tr>
    <tr><td class="paramname">s</td><td>New value for the attribute (which can be NULL).</td></tr>
  </table>
  </dd>
</dl>
<p>Returns an error if <code>name</code> is not a valid attribute name, or if the attribute is not a string attribute. </p>

</div>
</div>
<a class="anchor" id="gaab2d5904cd32a0b610e5241e97b8951f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_callback_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> **&#160;</td>
          <td class="paramname"><em>cb_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_thread *&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a callback object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_out</td><td>The allocated callback object is returned here </td></tr>
    <tr><td class="paramname">attr</td><td>Attributes </td></tr>
    <tr><td class="paramname">thread</td><td>The thread the callback will be used with</td></tr>
  </table>
  </dd>
</dl>
<p>This function allocates a callback object instance.</p>
<p>Before using the callback object the <a class="el" href="group__scapi.html#a269b9e0333c72f176e1fccaec7a3fe36">sc_callback::cb_handler_fn</a> field must be initialised. The <a class="el" href="group__scapi.html#aa0cd50a9379f993ac9f25c8496ff9d69">sc_callback::cb_private</a> field may be used to store or point to caller-specific state.</p>
<p>A callback object can only be registered with a single event source at a time. If a callback object is registered with an event source it is "active". If an active callback is registered with an event source, it is automatically removed from the previous event source. </p>

</div>
</div>
<a class="anchor" id="gab9b55e7300bd4998b5145baa500c214d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_callback_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a callback object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The callback object to free</td></tr>
  </table>
  </dd>
</dl>
<p>This function frees a callback object instance. </p>

</div>
</div>
<a class="anchor" id="ga1115fec0e84951a84556cb55efbea9b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sc_callback_is_active </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a callback object is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The callback object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae27afe9adda14a7baf27b27b02f32f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_callback_on_idle </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a callback when the thread is idle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The callback object</td></tr>
  </table>
  </dd>
</dl>
<p>The callback will be invoked from the associated thread's polling loop if there is no work done in that loop iteration. ie. The when thread is idle.</p>
<p>The callback is only invoked once. If further callbacks are wanted the callback must be reregistered explicitly. </p>

</div>
</div>
<a class="anchor" id="gaccf55062d866893054e81084e4eafc8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_callback_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister a callback object from its event source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The callback object</td></tr>
  </table>
  </dd>
</dl>
<p>This function has no effect if the callback object is not active. </p>

</div>
</div>
<a class="anchor" id="gacf9d08a80690f21e6d05c9d8bff5beb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_dlist_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise a pre-allocated <a class="el" href="group__scapi.html#structsc__dlist" title="Doubly linked list pointers. ">sc_dlist</a> to be an empty doubly linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A pointer to the pre-allocated <a class="el" href="group__scapi.html#structsc__dlist" title="Doubly linked list pointers. ">sc_dlist</a> to be initialised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga44bb5607d1f62036a3421a2cddf89390"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a>* sc_dlist_pop_head </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop off the head of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The point to pop the head from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b09ddf7b724b6bbeefd00ef587dbc80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a>* sc_dlist_pop_tail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the tail of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The point to pop the tail from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga23385fa685ba98c0a4dcf5cbbc22b494"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_dlist_push_head </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepend an item to the head of a doubly-linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to prepend to. </td></tr>
    <tr><td class="paramname">l</td><td>The item to prepend to <code>list</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga024f7bd3568d222bcb5a5bc1b6a466d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_dlist_push_tail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an item to the tail of a doubly-linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to append to. </td></tr>
    <tr><td class="paramname">l</td><td>The item to append to <code>list</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebfe64924e412c93836701b93c39f593"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_dlist_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__dlist">sc_dlist</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an item from the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The item to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6c57918e0012ba6fd32371c4db862913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_epoll_ctl </td>
          <td>(</td>
          <td class="paramtype">struct sc_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a callback when the thread is idle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread managing <code>fd</code> </td></tr>
    <tr><td class="paramname">op</td><td>EPOLL_CTL_ADD, EPOLL_CTL_MOD or EPOLL_CTL_DEL </td></tr>
    <tr><td class="paramname">fd</td><td>The file descriptor </td></tr>
    <tr><td class="paramname">events</td><td>Event flags (EPOLLIN, EPOLLOUT etc.) </td></tr>
    <tr><td class="paramname">cb</td><td>The callback object</td></tr>
  </table>
  </dd>
</dl>
<p>Request a callback when a file descriptor is readable or writable, or if op is EPOLL_CTL_DEL then cancel a callback.</p>
<p>This function uses epoll as the underlying mechanism to manage file descriptors, so please refer to the documentation of epoll for detailed semantics.</p>
<p><code>events</code> and <code>cb</code> are ignored when <code>op</code> is EPOLL_CTL_DEL.</p>
<p>A callback registered via this interface cannot be removed with <a class="el" href="group__scapi.html#gaccf55062d866893054e81084e4eafc8a" title="Unregister a callback object from its event source. ">sc_callback_remove</a>, and must not be re-registered with another event source without first calling <a class="el" href="group__scapi.html#ga6c57918e0012ba6fd32371c4db862913" title="Request a callback when the thread is idle. ">sc_epoll_ctl</a> with <code>op</code> set to EPOLL_CTL_DEL. </p>

</div>
</div>
<a class="anchor" id="gadee3bbd8865a6d15ecb982cfbf11bca0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_forward </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a> *&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward a single packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node's data structure </td></tr>
    <tr><td class="paramname">link</td><td>The link to forward to </td></tr>
    <tr><td class="paramname">packet</td><td>The packet to forward </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf1f892361f4b0bcc985bbf4169be5f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_forward_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a> *&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>pl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward a list of packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node's data structure </td></tr>
    <tr><td class="paramname">link</td><td>The link to forward to </td></tr>
    <tr><td class="paramname">pl</td><td>The list of packets to forward </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae97f0c16c9d01b4e3e647b6a178dffad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_iovec_copy_from_end </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data out of the end of a <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest_buf</td><td>Buffer to copy to. </td></tr>
    <tr><td class="paramname">iov</td><td>A pointer to an array of iovec objects. </td></tr>
    <tr><td class="paramname">iovlen</td><td>The number of iovec objects in <code>iov</code>. This must be &gt; 0. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: The caller must ensure that at least <code>bytes</code> of data are available in <code>iov</code> </p>

</div>
</div>
<a class="anchor" id="gac22fd8469d900114d03992219c2b3417"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sc_iovec_ptr_bytes </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *&#160;</td>
          <td class="paramname"><em>iovp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes represented by an <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iovp</td><td>The <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad7e58a9665f7fdfad4bd7791de96504d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_iovec_ptr_copy_out </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *&#160;</td>
          <td class="paramname"><em>iovp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data out of an <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Buffer to copy to </td></tr>
    <tr><td class="paramname">iovp</td><td>An <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> </td></tr>
    <tr><td class="paramname">max_bytes</td><td>Max number of bytes to copy (length of <code>dest</code>)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the number of bytes copied. </p>

</div>
</div>
<a class="anchor" id="gac84607d24ee7dc21304f5a60bd7e75f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_iovec_ptr_find_chr </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *&#160;</td>
          <td class="paramname"><em>iovp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find offset of character in iovec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iovp</td><td>An <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> </td></tr>
    <tr><td class="paramname">c</td><td>Character to find</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the offset of first occurrence of character <code>c</code> in the memory reference by <code>iovp</code>, or -1 if not found. </p>

</div>
</div>
<a class="anchor" id="gabd2802f23482b81e3bc832168758ee4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_iovec_ptr_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *&#160;</td>
          <td class="paramname"><em>iovp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise a struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iovp</td><td>The <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> to initialise </td></tr>
    <tr><td class="paramname">iov</td><td>Pointer to array of 'struct iovec's </td></tr>
    <tr><td class="paramname">iovlen</td><td>Length of the <code>iov</code> array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3852fd32e1bed2681c6bec7b97998ca0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_iovec_ptr_init_buf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *&#160;</td>
          <td class="paramname"><em>iovp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise a struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> with a contiguous buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iovp</td><td>The <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> to initialise </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to the start of the buffer </td></tr>
    <tr><td class="paramname">len</td><td>Length of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac4fe4eb92533707504279c26e57671a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_iovec_ptr_init_packet </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *&#160;</td>
          <td class="paramname"><em>iovp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise a struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> to point at packet data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iovp</td><td>The <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> to initialise </td></tr>
    <tr><td class="paramname">packet</td><td>The packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga73af931693a9526598e23b1800450c8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_iovec_ptr_skip </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *&#160;</td>
          <td class="paramname"><em>iovp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bytes_to_skip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip forward over an iovec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iovp</td><td>An <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> </td></tr>
    <tr><td class="paramname">bytes_to_skip</td><td>Number of bytes to skip over</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the number of bytes skipped, which may be fewer than <code>bytes_to_skip</code> if the total amount of memory referenced by <code>iovp</code> is less. </p>

</div>
</div>
<a class="anchor" id="gae3b02ad7e88dbdf27de5bc408bf48b89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_iovec_trim_end </td>
          <td>(</td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>iovlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove data from the end of an iovec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iov</td><td>A pointer to an array of iovec objects. </td></tr>
    <tr><td class="paramname">iovlen</td><td>The number of iovec objects in <code>iov</code>. </td></tr>
    <tr><td class="paramname">bytes</td><td>The number of bytes to trim.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: Caller must ensure that at least <code>bytes</code> of data are available in <code>iov</code>. </p>

</div>
</div>
<a class="anchor" id="ga674346831bf77ab6b65955ac013d47a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_join_mcast_group </td>
          <td>(</td>
          <td class="paramtype">struct sc_session *&#160;</td>
          <td class="paramname"><em>scs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a multicast group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scs</td><td>A session </td></tr>
    <tr><td class="paramname">interface</td><td>The network interface to join on </td></tr>
    <tr><td class="paramname">group</td><td>The multicast group to join</td></tr>
  </table>
  </dd>
</dl>
<p>This function joins multicast group <code>group</code> on interface <code>interface</code>. This is needed when you need to use the IGMP protocol to arrange that multicast packets are delivered to the adapter. </p>

</div>
</div>
<a class="anchor" id="ga4432c58f316ec4937aa3c0610a522c85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_mailbox_alloc </td>
          <td>(</td>
          <td class="paramtype">struct sc_mailbox **&#160;</td>
          <td class="paramname"><em>mb_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_thread *&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a mailbox. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb_out</td><td>The allocated mailbox is returned here. </td></tr>
    <tr><td class="paramname">attr</td><td>Attributes (see <a class="el" href="group__scapi.html#structsc__attr" title="Attribute object. ">sc_attr</a>). </td></tr>
    <tr><td class="paramname">thread</td><td>The thread the mailbox will be in.</td></tr>
  </table>
  </dd>
</dl>
<p>Mailboxes are used to pass packets between threads. To communicate you need a mailbox in each thread, and together they form a bi-directional link.</p>
<p>From SolarCapture 1.1 onwards it is not usually necessary to create mailboxes explicitly: They are created automatically when objects in different threads are connected together. </p>

</div>
</div>
<a class="anchor" id="ga179658a5950075de502cf74c5ab7a620"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_mailbox_connect </td>
          <td>(</td>
          <td class="paramtype">struct sc_mailbox *&#160;</td>
          <td class="paramname"><em>mb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_mailbox *&#160;</td>
          <td class="paramname"><em>mb2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect a pair of mailboxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb1</td><td>The first mailbox. </td></tr>
    <tr><td class="paramname">mb2</td><td>The second mailbox.</td></tr>
  </table>
  </dd>
</dl>
<p>Link a pair of mailboxes so that they can communicate. A mailbox can only be connected once. </p>

</div>
</div>
<a class="anchor" id="ga5104493c626279ce8480e7e42ef1a88a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a>* sc_mailbox_get_send_node </td>
          <td>(</td>
          <td class="paramtype">struct sc_mailbox *&#160;</td>
          <td class="paramname"><em>mailbox</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mailbox's "send node". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mailbox</td><td>The mailbox.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the mailbox's send-node. Packets passed to this send-node are forwarded to the paired mailboxes recv-node. </p>

</div>
</div>
<a class="anchor" id="ga2ab280593925991f558ba413315f93a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_mailbox_poll </td>
          <td>(</td>
          <td class="paramtype">struct sc_mailbox *&#160;</td>
          <td class="paramname"><em>mailbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll a mailbox. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mailbox</td><td>The mailbox to poll. </td></tr>
    <tr><td class="paramname">list</td><td>Received packets are appended to this list.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should only be invoked on an unmanaged mailbox. It is necessary to poll a mailbox in order to receive packets from other threads, and to ensure that sent packets are delivered. </p>

</div>
</div>
<a class="anchor" id="gadde326f7b7b77418c060c523c9beaa30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_mailbox_send </td>
          <td>(</td>
          <td class="paramtype">struct sc_mailbox *&#160;</td>
          <td class="paramname"><em>mailbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a packet through a mailbox to another thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mailbox</td><td>The mailbox. </td></tr>
    <tr><td class="paramname">packet</td><td>The packet to send.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should only be invoked on an unmanaged mailbox.</p>
<p>Invoke this function to place a packet on a mailbox's send queue. NB. The packet may not actually be delivered to the remote thread until a later call to <a class="el" href="group__scapi.html#ga2ab280593925991f558ba413315f93a3" title="Poll a mailbox. ">sc_mailbox_poll()</a>. </p>

</div>
</div>
<a class="anchor" id="ga98342f5d3bea6b55223081ef8badd378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_mailbox_send_list </td>
          <td>(</td>
          <td class="paramtype">struct sc_mailbox *&#160;</td>
          <td class="paramname"><em>mailbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a list of packets through a mailbox to another thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mailbox</td><td>The mailbox. </td></tr>
    <tr><td class="paramname">list</td><td>The packets to send.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should only be invoked on an unmanaged mailbox.</p>
<p>Invoke this function to place packets on a mailbox's send queue. NB. The packets may not actually be delivered to the remote thread until a later call to <a class="el" href="group__scapi.html#ga2ab280593925991f558ba413315f93a3" title="Poll a mailbox. ">sc_mailbox_poll()</a>. </p>

</div>
</div>
<a class="anchor" id="gad4e3b4c2ee7e80fb5e118f9cc9303258"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_mailbox_set_recv </td>
          <td>(</td>
          <td class="paramtype">struct sc_mailbox *&#160;</td>
          <td class="paramname"><em>mailbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect a mailbox to a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mailbox</td><td>The mailbox. </td></tr>
    <tr><td class="paramname">node</td><td>The node. </td></tr>
    <tr><td class="paramname">name_opt</td><td>Optional ingress port name (may be NULL).</td></tr>
  </table>
  </dd>
</dl>
<p>Connect the output of a mailbox to a node. Packets passed to the send-node of the paired mailbox are passed to <code>node</code>. </p>

</div>
</div>
<a class="anchor" id="gaaf52bfbee29e202cd9c1e23ecce47fb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_node_add_info_int </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>field_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export information to solar_capture_monitor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node exporting state. </td></tr>
    <tr><td class="paramname">field_name</td><td>Name of field. </td></tr>
    <tr><td class="paramname">field_val</td><td>State to export.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to export static runtime information about a node to solar_capture_monitor. This function can be used in the implementation of a new node type, or in an application using a node.</p>
<p>See also <a class="el" href="group__scapi.html#ga3a9ffadf72bc8ee9acda36d8c44253fe" title="Export information to solar_capture_monitor. ">sc_node_add_info_str()</a> and <a class="el" href="group__scapi.html#gacc6af7c03d777dc736d6d8bdba1dead2" title="Export dynamic state to solar_capture_monitor. ">sc_node_export_state()</a>. </p>

</div>
</div>
<a class="anchor" id="ga3a9ffadf72bc8ee9acda36d8c44253fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_node_add_info_str </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>field_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export information to solar_capture_monitor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node exporting state. </td></tr>
    <tr><td class="paramname">field_name</td><td>Name of field. </td></tr>
    <tr><td class="paramname">field_val</td><td>State to export.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to export static runtime information about a node to solar_capture_monitor. This function can be used in the implementation of a new node type, or in an application using a node.</p>
<p>See also <a class="el" href="group__scapi.html#gaaf52bfbee29e202cd9c1e23ecce47fb1" title="Export information to solar_capture_monitor. ">sc_node_add_info_int()</a> and <a class="el" href="group__scapi.html#gacc6af7c03d777dc736d6d8bdba1dead2" title="Export dynamic state to solar_capture_monitor. ">sc_node_export_state()</a>. </p>

</div>
</div>
<a class="anchor" id="ga25ee0880d5b47c78a5d1b07926f9fb4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_node_add_link </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>from_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>to_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_name_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a link from one node to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_node</td><td>Node to connect from. </td></tr>
    <tr><td class="paramname">link_name</td><td>Name of the <code>from_node's</code> egress link. </td></tr>
    <tr><td class="paramname">to_node</td><td>Node to connect to. </td></tr>
    <tr><td class="paramname">to_name_opt</td><td>Optional ingress port name (may be NULL).</td></tr>
  </table>
  </dd>
</dl>
<p>Packets flow from node to node along links. This function adds a link from <code>from_node</code> to <code>to_node</code>.</p>
<p><code>link_name</code> identifies <code>from_node's</code> egress link. By convention the default egress link is named "".</p>
<p>Some node types support multiple ingress ports so that the node can receive and separate multiple incoming packet streams. The name of the ingress port is given by <code>to_name_opt</code>.</p>
<p>Since SolarCapture 1.1, if the nodes are in different threads then this function automatically creates a link between the threads using mailboxes. </p>

</div>
</div>
<a class="anchor" id="ga15eae832e9b93996b7ee5e311c991cf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_node_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> **&#160;</td>
          <td class="paramname"><em>node_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__node__factory">sc_node_factory</a> *&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__arg">sc_arg</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a packet processing node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_out</td><td>The allocated node is returned here </td></tr>
    <tr><td class="paramname">attr</td><td>Attributes </td></tr>
    <tr><td class="paramname">thread</td><td>The thread the node will be in </td></tr>
    <tr><td class="paramname">factory</td><td>A node factory </td></tr>
    <tr><td class="paramname">args</td><td>An array of arguments for node initialisation </td></tr>
    <tr><td class="paramname">n_args</td><td>The number of arguments</td></tr>
  </table>
  </dd>
</dl>
<p>Nodes perform packet processing services such as filtering, packet modification, import/export and packet injection.</p>
<p>A node factory allocates nodes of a particular type, and the argument list provides configuration for the node instance.</p>
<p>Use this function when you have a pointer to the node factory. For built-in nodes or nodes in a separate library it is simpler to use <a class="el" href="group__scapi.html#ga7a27a36506cdbb62afcaaeb812ef1b6e" title="Allocate a packet processing node by name. ">sc_node_alloc_named()</a>. </p>

</div>
</div>
<a class="anchor" id="ga7a27a36506cdbb62afcaaeb812ef1b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_node_alloc_named </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> **&#160;</td>
          <td class="paramname"><em>node_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>factory_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lib_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__arg">sc_arg</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a packet processing node by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_out</td><td>The allocated node is returned here. </td></tr>
    <tr><td class="paramname">attr</td><td>Attributes. </td></tr>
    <tr><td class="paramname">thread</td><td>The thread the node will be in. </td></tr>
    <tr><td class="paramname">factory_name</td><td>Name of the node factory. </td></tr>
    <tr><td class="paramname">lib_name</td><td>Name of the node library (may be NULL). </td></tr>
    <tr><td class="paramname">args</td><td>An array of arguments for node initialisation. </td></tr>
    <tr><td class="paramname">n_args</td><td>The number of arguments.</td></tr>
  </table>
  </dd>
</dl>
<p>Nodes perform packet processing services such as filtering, packet modification, import/export and packet injection.</p>
<p>This function allocates a node of type <code>factory_name</code>, and the argument list provides configuration for the node instance.</p>
<p>This function is a short-cut for <a class="el" href="group__scapi.html#gafa1ef25849867e989035103317980d50" title="Find a node factory. ">sc_node_factory_lookup()</a> followed by <a class="el" href="group__scapi.html#ga15eae832e9b93996b7ee5e311c991cf4" title="Allocate a packet processing node. ">sc_node_alloc()</a>. </p>

</div>
</div>
<a class="anchor" id="gacc6af7c03d777dc736d6d8bdba1dead2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_node_export_state </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pp_area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export dynamic state to solar_capture_monitor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node exporting state </td></tr>
    <tr><td class="paramname">type_name</td><td>Name of the exported datastructure </td></tr>
    <tr><td class="paramname">type_size</td><td>Size in bytes of the exported datastructure </td></tr>
    <tr><td class="paramname">pp_area</td><td>Pointer to memory is returned here</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to export dynamic runtime information about a node to solar_capture_monitor. The information can include configuration information, statistics and/or other runtime state.</p>
<p><code>pp_area</code> gives the address of a pointer that is overwritten with a pointer to the memory area large enough for an instance of <code>type_name</code>. So <code>pp_area</code> should be of type 'struct type_name**'.</p>
<p>The type <code>type_name</code> must already have been declared by creating the type_name_declare() function using declare_types.h::SC_DECLARE_TYPES and calling it.</p>
<p>See also <a class="el" href="group__scapi.html#ga3a9ffadf72bc8ee9acda36d8c44253fe" title="Export information to solar_capture_monitor. ">sc_node_add_info_str()</a> and <a class="el" href="group__scapi.html#gaaf52bfbee29e202cd9c1e23ecce47fb1" title="Export information to solar_capture_monitor. ">sc_node_add_info_int()</a>, which are useful for exporting static data. </p>

</div>
</div>
<a class="anchor" id="gafa1ef25849867e989035103317980d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_node_factory_lookup </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__node__factory">sc_node_factory</a> **&#160;</td>
          <td class="paramname"><em>factory_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>factory_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lib_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node factory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory_out</td><td>The node factory found. </td></tr>
    <tr><td class="paramname">session</td><td>The SolarCapture session. </td></tr>
    <tr><td class="paramname">factory_name</td><td>Name of the node factory. </td></tr>
    <tr><td class="paramname">lib_name</td><td>Name of the node library (may be NULL).</td></tr>
  </table>
  </dd>
</dl>
<p>Finds the factory of name <code>factory_name</code>. It may be a built-in factory (in which case <code>lib_name</code> should be NULL) or a factory in an external library.</p>
<p>A factory library is a shared object file that contains one or more node factory instances.</p>
<p><code>lib_name</code> may be NULL, in which case it defaults to being the same as the <code>factory_name</code>.</p>
<p>If <code>lib_name</code> contains a '/' character it is treated as the full path to the library object file.</p>
<p>Otherwise <code>lib_name</code> is the name of the library object file (either with or without a .so suffix). This function will search for the library object file in the following directories (in order):</p>
<ul>
<li>the current working directory</li>
<li>directories specified by the SC_NODE_PATH environment variable</li>
<li>/usr/lib64/solar_capture/site-nodes</li>
<li>/usr/lib/x86_64-linux-gnu/solar_capture/site-nodes</li>
<li>/usr/lib64/solar_capture/nodes</li>
<li>/usr/lib/x86_64-linux-gnu/solar_capture/nodes</li>
</ul>
<p>Depending on the target system, not all of the above directories may exist. In particular, the subdirectories of /usr/lib/x86_64-linux-gnu/ will only exist on Debian-derived systems using the multiarch structure for library folders. This is not expected to cause a problem at runtime.</p>
<p>If we decide to support 32-bit builds again, these directories will be searched instead (in order):</p>
<ul>
<li>the current working directory</li>
<li>directories specified by the SC_NODE_PATH environment variable</li>
<li>/usr/lib/solar_capture/site-nodes</li>
<li>/usr/lib/i386-linux-gnu/solar_capture/site-nodes</li>
<li>/usr/lib/solar_capture/nodes</li>
<li>/usr/lib/i386-linux-gnu/solar_capture/nodes</li>
</ul>
<p>If a library containing the named factory is not found by this search, the built-in nodes are searched last. </p>

</div>
</div>
<a class="anchor" id="gad96a64c4b5acc86bf4f034ddabc94759"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_thread* sc_node_get_thread </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the thread associated with a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad4d88678d97b0e12bfce83f727f4946d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_node_init_get_arg_dbl </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v_default</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a double argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_out</td><td>On success, the value is returned here </td></tr>
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">name</td><td>The name of the argument </td></tr>
    <tr><td class="paramname">v_default</td><td>Default returned if arg not found</td></tr>
  </table>
  </dd>
</dl>
<p>This may only be called from <a class="el" href="group__scapi.html#gaec792135358df254bea89bb9dd6a2a09" title="Signature of function to initialise a node. ">sc_node_init_fn</a>. Returns 0 if the argument is found, else 1 if not found (in which case <code>v_default</code> is copied to <code>v_out</code>), or -1 if the argument was found but is of the wrong type. </p>

</div>
</div>
<a class="anchor" id="ga9bd2400efd3c0209a49cc61aacc37a2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_node_init_get_arg_int </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>v_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v_default</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an integer argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_out</td><td>On success, the value is returned here </td></tr>
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">name</td><td>The name of the argument </td></tr>
    <tr><td class="paramname">v_default</td><td>Default returned if arg not found</td></tr>
  </table>
  </dd>
</dl>
<p>This may only be called from <a class="el" href="group__scapi.html#gaec792135358df254bea89bb9dd6a2a09" title="Signature of function to initialise a node. ">sc_node_init_fn</a>. Returns 0 if the argument is found, else 1 if not found (in which case v_default is copied to v_out), or -1 if the argument was found but is of the wrong type. </p>

</div>
</div>
<a class="anchor" id="ga1015ae5984c472c9303da9fa058f22c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_node_init_get_arg_obj </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> **&#160;</td>
          <td class="paramname"><em>obj_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__scapi.html#ga7dbec837a1592a9f6a4bc649ea583f0d">sc_object_type</a>&#160;</td>
          <td class="paramname"><em>obj_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a> argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_out</td><td>On success, the value is returned here </td></tr>
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">name</td><td>The name of the argument </td></tr>
    <tr><td class="paramname">obj_type</td><td>The type of object wanted, or SC_OBJ_ANY</td></tr>
  </table>
  </dd>
</dl>
<p>This may only be called from <a class="el" href="group__scapi.html#gaec792135358df254bea89bb9dd6a2a09" title="Signature of function to initialise a node. ">sc_node_init_fn</a>. Returns 0 if the argument is found, else 1 if not found, or -1 if the argument was found but is of the wrong type (i.e. not an object, or the wrong type of object). </p>

</div>
</div>
<a class="anchor" id="ga39a8d3878cb771e5db654686264fae37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_node_init_get_arg_str </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>v_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>v_default</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an string argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_out</td><td>On success, the value is returned here </td></tr>
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">name</td><td>The name of the argument </td></tr>
    <tr><td class="paramname">v_default</td><td>Default returned if arg not found</td></tr>
  </table>
  </dd>
</dl>
<p>This may only be called from <a class="el" href="group__scapi.html#gaec792135358df254bea89bb9dd6a2a09" title="Signature of function to initialise a node. ">sc_node_init_fn</a>. Returns 0 if the argument is found, else 1 if not found (in which case v_default is copied to v_out), or -1 if the argument was found but is of the wrong type.</p>
<p>The string returned is valid only until the <a class="el" href="group__scapi.html#gaec792135358df254bea89bb9dd6a2a09" title="Signature of function to initialise a node. ">sc_node_init_fn</a> call returns. </p>

</div>
</div>
<a class="anchor" id="ga31a56ca7cf9cb5339613bb8c3414662d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_node_link_end_of_stream </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a> *&#160;</td>
          <td class="paramname"><em>link</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate end-of-stream on a link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">link</td><td>The link</td></tr>
  </table>
  </dd>
</dl>
<p>It is a fatal error to forward any further packets through the link after calling this function. </p>

</div>
</div>
<a class="anchor" id="ga812b8c2064d246dda6d27262edadcfb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_node_prep_check_links </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the node's links for any unused links. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node</td></tr>
  </table>
  </dd>
</dl>
<p>This may only be called from <a class="el" href="group__scapi.html#ga4be5c52459c32aba638861f7d775b223" title="Signature of nt_prep_fn function. ">sc_node_prep_fn()</a>, and should only be used by nodes that find their links by calling <a class="el" href="group__scapi.html#ga60db329829493afd47f6fafee17fe3a4" title="Find a named outgoing link. ">sc_node_prep_get_link()</a>.</p>
<p>This function will complain about any links added to the node that have not been queried by <a class="el" href="group__scapi.html#ga60db329829493afd47f6fafee17fe3a4" title="Find a named outgoing link. ">sc_node_prep_get_link()</a>. It may emit a warning, or generate an error.</p>
<p>Returns 0 if all is fine (or only warnings are needed). Returns -1 on error, which should be propagated out of <a class="el" href="group__scapi.html#ga4be5c52459c32aba638861f7d775b223" title="Signature of nt_prep_fn function. ">sc_node_prep_fn()</a>. </p>

</div>
</div>
<a class="anchor" id="ga60db329829493afd47f6fafee17fe3a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a>* sc_node_prep_get_link </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>link_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a named outgoing link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">link_name</td><td>Name of the link</td></tr>
  </table>
  </dd>
</dl>
<p>It returns NULL if the named link doesn't exist.</p>
<p>A node's <a class="el" href="group__scapi.html#ga4be5c52459c32aba638861f7d775b223" title="Signature of nt_prep_fn function. ">sc_node_prep_fn</a> can either use this mechanism to query its links, or it can simply iterate over the links passed as arguments to <a class="el" href="group__scapi.html#ga4be5c52459c32aba638861f7d775b223" title="Signature of nt_prep_fn function. ">sc_node_prep_fn</a>.</p>
<p>This function may only be called from <a class="el" href="group__scapi.html#ga4be5c52459c32aba638861f7d775b223" title="Signature of nt_prep_fn function. ">sc_node_prep_fn</a>.</p>
<p>See also <a class="el" href="group__scapi.html#ga812b8c2064d246dda6d27262edadcfb8" title="Check the node&#39;s links for any unused links. ">sc_node_prep_check_links()</a>. </p>

</div>
</div>
<a class="anchor" id="ga08ed504e3035033bbded0103cee77e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a>* sc_node_prep_get_link_or_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>link_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a named outgoing link or return a link for freeing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">link_name</td><td>Name of the link</td></tr>
  </table>
  </dd>
</dl>
<p>This function behaves just like <a class="el" href="group__scapi.html#ga60db329829493afd47f6fafee17fe3a4" title="Find a named outgoing link. ">sc_node_prep_get_link()</a>, except that if no link of that name has been added to the node, a special link is returned that frees packets.</p>
<p><code>link_name</code> may be NULL, in which case a link for freeing packets is returned. </p>

</div>
</div>
<a class="anchor" id="ga57655c20c2be20d06739cd948a698fc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_node_prep_get_pool </td>
          <td>(</td>
          <td class="paramtype">struct sc_pool **&#160;</td>
          <td class="paramname"><em>pool_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__node__link">sc_node_link</a> *const *&#160;</td>
          <td class="paramname"><em>links</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_links</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a packet pool that can be used to obtain empty packet buffers that can be passed to any of the given set of links. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool_out</td><td>On success, the pool is returned here </td></tr>
    <tr><td class="paramname">attr</td><td>Packet pool attributes (optional, may be NULL) </td></tr>
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">links</td><td>The link(s) packets from the pool may be passed to (set to NULL for all) </td></tr>
    <tr><td class="paramname">n_links</td><td>Number of links in 'links'</td></tr>
  </table>
  </dd>
</dl>
<p>The node must only forward packets from the returned pool over the links identified by <code>links</code> and <code>n_links</code>. If <code>n_links</code> is 0 then it is assumed that packets from the pool may be forwarded over any of the node's links.</p>
<p>Restricting the links packets can be sent along allows SolarCapture to optimise the releasing of packets back to the pool when the node graph is finished with them.</p>
<p>This may only be called from <a class="el" href="group__scapi.html#ga4be5c52459c32aba638861f7d775b223" title="Signature of nt_prep_fn function. ">sc_node_prep_fn</a>. </p>

</div>
</div>
<a class="anchor" id="gab0038076a80275fb7bbc9e5358503d3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_node_type_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node__type">sc_node_type</a> **&#160;</td>
          <td class="paramname"><em>nt_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr_opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__node__factory">sc_node_factory</a> *&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an <a class="el" href="group__scapi.html#structsc__node__type" title="Describes a type of node. ">sc_node_type</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt_out</td><td>The allocated <a class="el" href="group__scapi.html#structsc__node__type" title="Describes a type of node. ">sc_node_type</a> instance </td></tr>
    <tr><td class="paramname">attr_opt</td><td>Optional attributes (may be NULL) </td></tr>
    <tr><td class="paramname">factory</td><td>The factory that created the node</td></tr>
  </table>
  </dd>
</dl>
<p>At the time of writing <code>attr_opt</code> is not used and this call always succeeds. In future it may fail if the attributes are invalid in some way. </p>

</div>
</div>
<a class="anchor" id="gadf81a2fdc8da8b7d856376d134ac956b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sc_ns_from_ms </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert milliseconds to nanoseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>The time in milliseconds to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time in nanoseconds </dd></dl>

</div>
</div>
<a class="anchor" id="gafa59c9313b81184570c3d4b853c2b0ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sc_ns_from_ts </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a timespec struct to nanoseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ts</td><td>The timespec struct to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time in nanoseconds </dd></dl>

</div>
</div>
<a class="anchor" id="gac387bbd504137d73a3be79d2fc0d0f5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sc_ns_from_tv </td>
          <td>(</td>
          <td class="paramtype">const struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a timeval struct to nanoseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tv</td><td>The timeval struct to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time in nanoseconds </dd></dl>

</div>
</div>
<a class="anchor" id="gafd9b5615c46ce721e564d384ff9521c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t sc_ns_from_us </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert microseconds to nanoseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">us</td><td>The time in microseconds to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time in nanoseconds </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f8d3d54946468e02b0ff6cfd3da9011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__scapi.html#ga7dbec837a1592a9f6a4bc649ea583f0d">sc_object_type</a> <a class="el" href="group__scapi.html#ga7dbec837a1592a9f6a4bc649ea583f0d">sc_object_type</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of data contained within the <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to check the data type of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5cf52b03c8c1928ed4c3f4d2a16961dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_opaque_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> **&#160;</td>
          <td class="paramname"><em>obj_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for an opaque <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_out</td><td>On success the allocated object. </td></tr>
    <tr><td class="paramname">opaque</td><td>A pointer to the data to be wrapped by the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b4eb6fd151e9e6765dd4f643a4fe5fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_opaque_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a> previously allocated using <a class="el" href="group__scapi.html#ga5cf52b03c8c1928ed4c3f4d2a16961dd" title="Allocate memory for an opaque sc_object. ">sc_opaque_alloc</a>. Only use this to free an opaque <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>. The underlying data wrapped by this object will not be freed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6b65f0f7cfa229dcca425ea077e2c55b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_opaque_get_ptr </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the opaque pointer stored in an <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to fetch the opaque pointer from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The opaque pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="gaab8278ca64eaa658b719cc965b0e3ee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_opaque_set_ptr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the opaque pointer in an <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object to set the pointer on </td></tr>
    <tr><td class="paramname">opaque</td><td>The new opaque pointer to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8093bbe733b0222fbca55585685ac16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_packet_append_iovec_ptr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_pool *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__iovec__ptr">sc_iovec_ptr</a> *&#160;</td>
          <td class="paramname"><em>iovp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>snap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append data to a packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>The packet to append data to </td></tr>
    <tr><td class="paramname">pool</td><td>Packet pool to allocate frag buffers from (optional) </td></tr>
    <tr><td class="paramname">iovp</td><td>Identifies the data to copy in </td></tr>
    <tr><td class="paramname">snap</td><td>The maximum number of bytes to copy in</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 if all the requested data could be appended. Returns -1 if more space was needed and it was not possible to allocate fragment buffers. Returns -2 if the packet runs out of space (ie. the fragments chain would exceed the maximum chain length).</p>
<p>If you need to know the number of bytes appended, compare the packet frame_len before and after the call. </p>

</div>
</div>
<a class="anchor" id="ga86a57ce4b42726de7c3f19d0db72e29b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sc_packet_bytes </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the packet data in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A packet object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0f913fe7a127765c02a200e939f5ecc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a>* sc_packet_frags_tail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a packet's last fragment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A packet object.</td></tr>
  </table>
  </dd>
</dl>
<p>The result is only valid if the packet has at least one fragment. </p>

</div>
</div>
<a class="anchor" id="ga1466e528075a1601af2fbd69c2e14dc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_packet_list_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a packet to a list and finalise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The packet list. </td></tr>
    <tr><td class="paramname">p</td><td>The packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9383f0aeb20125c7433a9d4929cbcabe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_packet_list_append_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a list to a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The list to be extended. </td></tr>
    <tr><td class="paramname">src</td><td>The list to be appended to <code>dest</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>After this call <code>dest</code> is finalised if and only if <code>src</code> was finalised.</p>
<p><code>src</code> must be non-empty. </p>

</div>
</div>
<a class="anchor" id="ga27605a80d75a6e52df01dd7a5a70cb1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_packet_list_finalise </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalise a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The packet list.</td></tr>
  </table>
  </dd>
</dl>
<p>If a list is not finalised, it is possible that the next pointer of tail is not NULL. </p>

</div>
</div>
<a class="anchor" id="ga800166fc20af90e8ffd591fd56a502df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_packet_list_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The packet list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a5023853852a43058414361b743cf86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sc_packet_list_is_empty </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if packet list is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The packet list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad713ca3a98e3e6146ea8c2252553201e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a>* sc_packet_list_pop_head </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>pl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove and return the head of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pl</td><td>The packet list.</td></tr>
  </table>
  </dd>
</dl>
<p>This must only be invoked on a non-empty list. </p>

</div>
</div>
<a class="anchor" id="ga8843276b4c2fdb4d4dcc38dbd9f290f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_packet_list_push_head </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>pl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a packet to the head of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pl</td><td>The packet list. </td></tr>
    <tr><td class="paramname">p</td><td>The packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf16773cf50c92ce8a87d0afe1798e15c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a>* sc_packet_list_tail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tail of current tail of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The packet list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga49aadbcf993ff1eac6009514e66d1fba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_packet_prefetch_r </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefetch a packet for reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A packet object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f0139e0b61551a63b7581e1aa7f7167"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sc_packet_prefetch_rw </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefetch a packet for reading and writing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A packet object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3803622499b77c68d60e5c281d6f3f21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct timespec sc_packet_timespec </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the timestamp of the packet in timespec format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A packet object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga35454255cfdaa226a20011eecbc330db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_pkt_predicate_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__pkt__predicate">sc_pkt_predicate</a> **&#160;</td>
          <td class="paramname"><em>pred_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>private_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a packet predicate object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred_out</td><td>On success the allocated <a class="el" href="group__scapi.html#structsc__pkt__predicate" title="A packet predicate object. ">sc_pkt_predicate</a> object. </td></tr>
    <tr><td class="paramname">private_bytes</td><td>Size of private memory area wanted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success.</dd></dl>
<p>Packet predicates are used to test packets against some criteria. The test function should return true (1) or false (0).</p>
<p>If <code>private_bytes</code> is non-zero then <code>pred_private</code> is initialised with a pointer to a region of memory of size <code>private_bytes</code>. The <code>pred_private</code> field may be used by the implementation to hold state. </p>

</div>
</div>
<a class="anchor" id="ga4b31433e450ec1a8e237b412fc42c338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__scapi.html#structsc__pkt__predicate">sc_pkt_predicate</a>* sc_pkt_predicate_from_object </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a> into a <a class="el" href="group__scapi.html#structsc__pkt__predicate" title="A packet predicate object. ">sc_pkt_predicate</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>An <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a> instance or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if <code>obj</code> is NULL otherwise the converted <a class="el" href="group__scapi.html#structsc__pkt__predicate" title="A packet predicate object. ">sc_pkt_predicate</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga774b93770aa8945186b1cc2fc589049a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__scapi.html#structsc__object">sc_object</a>* sc_pkt_predicate_to_object </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__pkt__predicate">sc_pkt_predicate</a> *&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="group__scapi.html#structsc__pkt__predicate" title="A packet predicate object. ">sc_pkt_predicate</a> into a <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>An <a class="el" href="group__scapi.html#structsc__pkt__predicate" title="A packet predicate object. ">sc_pkt_predicate</a> instance or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if <code>pred</code> is NULL otherwise the converted <a class="el" href="group__scapi.html#structsc__object" title="An opaque object. Use this to pass all types of data that are not ints, doubles or char arrays (see S...">sc_object</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga43bdfc20c5bd5ee6fa5fe0ca4e83c893"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a>* sc_pool_duplicate_packet </td>
          <td>(</td>
          <td class="paramtype">struct sc_pool *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet">sc_packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>snap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool to allocate buffers from </td></tr>
    <tr><td class="paramname">packet</td><td>The packet to duplicate </td></tr>
    <tr><td class="paramname">snap</td><td>The maximum number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f076c7861f6500e193ad2f25b436ad1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_pool_get_packets </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_pool *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_packets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get packet buffers from a pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>List where retrieved packets are placed </td></tr>
    <tr><td class="paramname">pool</td><td>The packet pool </td></tr>
    <tr><td class="paramname">min_packets</td><td>Minimum number of buffers to be returned </td></tr>
    <tr><td class="paramname">max_packets</td><td>Maximum number of buffers to be returned</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the number of buffers added to <code>list</code>, or -1 if the minimum could not be satisfied.</p>
<p><code>list</code> must be initialised on entry (and may already contain some packets), but need not be finalised. The list is finalised on return unless an error is returned (in which case the list is not modified).</p>
<p>Each packet returned is initialised as follows: pkt-&gt;flags = 0; pkt-&gt;frame_len = 0; pkt-&gt;iovlen = 1; pkt-&gt;iov[0] gives the base and extent of the DMA area The fragment list is empty</p>
<p>The following packet fields have undefined values: ts_sec, ts_nsec. </p>

</div>
</div>
<a class="anchor" id="gab65a15a5724e993cd3b819006d3a0ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_pool_on_threshold </td>
          <td>(</td>
          <td class="paramtype">struct sc_pool *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a callback when the pool is refilled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The packet pool </td></tr>
    <tr><td class="paramname">event</td><td>The event object </td></tr>
    <tr><td class="paramname">threshold</td><td>Event fires when pool has &gt;= threshold buffers</td></tr>
  </table>
  </dd>
</dl>
<p>Registers an event handler that is invoked when the pool fill level reaches the specified threshold. If the pool fill level is already at or above the threshold, the handler will be invoked as soon as possible. </p>

</div>
</div>
<a class="anchor" id="ga845097c04ecb97bc8769111d8ae94a98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_pool_return_packets </td>
          <td>(</td>
          <td class="paramtype">struct sc_pool *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__packet__list">sc_packet_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return packets to a pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The packet pool </td></tr>
    <tr><td class="paramname">list</td><td>List of packets to return</td></tr>
  </table>
  </dd>
</dl>
<p><code>list</code> must be initialised on entry, but can be empty. The packets on the list can have frags. </p>

</div>
</div>
<a class="anchor" id="gaeb3b520ff2455e773c8328e52665dcd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_session_alloc </td>
          <td>(</td>
          <td class="paramtype">struct sc_session **&#160;</td>
          <td class="paramname"><em>scs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a SolarCapture session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scs_out</td><td>The allocated session object is returned here </td></tr>
    <tr><td class="paramname">attr</td><td>Attributes for the new session</td></tr>
  </table>
  </dd>
</dl>
<p>This function allocates a SolarCapture session.</p>
<p>A session comprises a set of threads, VIs, nodes and/or other SolarCapture objects. </p>

</div>
</div>
<a class="anchor" id="ga38fd2b69598273e1fa68698f7f1a6e7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_session_error_free </td>
          <td>(</td>
          <td class="paramtype">struct sc_session *&#160;</td>
          <td class="paramname"><em>scs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__session__error">sc_session_error</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees an error object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scs</td><td>The session </td></tr>
    <tr><td class="paramname">err</td><td>The error</td></tr>
  </table>
  </dd>
</dl>
<p>Frees a <a class="el" href="group__scapi.html#structsc__session__error" title="A SolarCapture session error object returned by sc_session_error_get. ">sc_session_error</a> pointer returned by <a class="el" href="group__scapi.html#gaa2ed816358bceda7232241aec4a56fc2" title="Returns an error from a SolarCapture session. ">sc_session_error_get</a>. </p>

</div>
</div>
<a class="anchor" id="gaa2ed816358bceda7232241aec4a56fc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__scapi.html#structsc__session__error">sc_session_error</a>* sc_session_error_get </td>
          <td>(</td>
          <td class="paramtype">struct sc_session *&#160;</td>
          <td class="paramname"><em>scs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an error from a SolarCapture session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scs</td><td>The session</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a pointer to a <a class="el" href="group__scapi.html#structsc__session__error" title="A SolarCapture session error object returned by sc_session_error_get. ">sc_session_error</a> struct representing the error encountered by session <code>scs</code>. The caller should pass the pointer to <a class="el" href="group__scapi.html#ga38fd2b69598273e1fa68698f7f1a6e7f" title="Frees an error object. ">sc_session_error_free</a> once once done with it.</p>
<p>If no error has occurred, this function returns NULL. </p>

</div>
</div>
<a class="anchor" id="ga7ce051535aeecdd0d0c5dc29e3ff4ed4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_session_go </td>
          <td>(</td>
          <td class="paramtype">struct sc_session *&#160;</td>
          <td class="paramname"><em>scs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a SolarCapture session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scs</td><td>The session</td></tr>
  </table>
  </dd>
</dl>
<p>Prepare the session <code>scs</code> (if necessary) and start the managed threads. This is usually called just once, after allocating resources. It can also be called after <a class="el" href="group__scapi.html#gad0b0679c812770607440d7cbd6dff06a" title="Pause a SolarCapture session. ">sc_session_pause()</a> to restart a paused session. </p>

</div>
</div>
<a class="anchor" id="gad0b0679c812770607440d7cbd6dff06a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_session_pause </td>
          <td>(</td>
          <td class="paramtype">struct sc_session *&#160;</td>
          <td class="paramname"><em>scs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause a SolarCapture session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scs</td><td>The session</td></tr>
  </table>
  </dd>
</dl>
<p>Pause the threads managed by session <code>scs</code>. </p>

</div>
</div>
<a class="anchor" id="ga51670c28c622d5628e4556079707b39f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_session_prepare </td>
          <td>(</td>
          <td class="paramtype">struct sc_session *&#160;</td>
          <td class="paramname"><em>scs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a SolarCapture session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scs</td><td>The session</td></tr>
  </table>
  </dd>
</dl>
<p>Prepare the session <code>scs</code>. This step includes finalising resource allocations, preparing nodes, and starting packet capture. Managed threads are started in the "paused" state.</p>
<p>Note that although packet capture is started, you may get packet loss if the threads managing '<a class="el" href="group__scapi.html#structsc__vi" title="A VI object. ">sc_vi</a>'s are not started soon afterwards.</p>
<p>Call <a class="el" href="group__scapi.html#ga7ce051535aeecdd0d0c5dc29e3ff4ed4" title="Start a SolarCapture session. ">sc_session_go()</a> to start the managed threads and begin packet processing. </p>

</div>
</div>
<a class="anchor" id="ga030ee27014d1cdb02a585692aa080d4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_all </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this stream to capture all packets that haven't been caught by another stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="ga2f28b2f34cfb3987a0d033f548578521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_alloc </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream **&#160;</td>
          <td class="paramname"><em>stream_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_session *&#160;</td>
          <td class="paramname"><em>scs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new stream object for this session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_out</td><td>On success, the created stream. </td></tr>
    <tr><td class="paramname">attr</td><td>Attributes to pass in. </td></tr>
    <tr><td class="paramname">scs</td><td>The session this stream is for.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns 0 on success or a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="ga560887a0eba175ff112a7bd397f60bf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_eth_dhost </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>mac_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this stream to capture all packets with the matching destination MAC address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to. </td></tr>
    <tr><td class="paramname">mac_addr</td><td>The destination MAC address to match against.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="ga9c29f537440d7ab981724ae5694210a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_eth_shost </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>mac_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this stream to capture all packets with the matching source MAC address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to. </td></tr>
    <tr><td class="paramname">mac_addr</td><td>The source MAC address to match against.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="gaafdd45b9c9cd2b3d9bbed484edb039ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_eth_type </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>eth_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configrue this stream to capture all packets with the matching ethernet type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to. </td></tr>
    <tr><td class="paramname">eth_type</td><td>The internet layer protocol to match against.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="ga4dfd4b9ce0e999709c99595671457815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_eth_vlan_id </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vlan_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this stream to capture all packets with the matching VLAN ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to. </td></tr>
    <tr><td class="paramname">vlan_id</td><td>The VLAN ID to match against.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="ga7ccf1f450ad2ed7193b0972654d7b4aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_free </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a previously created stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to free.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will always return 0. </p>

</div>
</div>
<a class="anchor" id="ga6e35061b4f1eb046e2ed9643d43f92b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_ip_dest_host </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this stream to capture all packets with matching destination hostname. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to. </td></tr>
    <tr><td class="paramname">dhost</td><td>The destination hostname to match against.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="ga5b44193c6dc23afc8c5084c46408fa5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_ip_dest_hostport </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dhost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this stream to capture all packets with the matching protocol, destination hostname and destination port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to. </td></tr>
    <tr><td class="paramname">protocol</td><td>The transport layer protocol to match against. </td></tr>
    <tr><td class="paramname">dhost</td><td>The destination hostname to match against. </td></tr>
    <tr><td class="paramname">dport</td><td>The destination port to match against.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="gaab53fdb27f1a14621f163fbb133b7aa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_ip_dest_port </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this stream to capture all packets with matching destination port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to. </td></tr>
    <tr><td class="paramname">dport</td><td>The destination port to match against.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="ga67930eefc09c804a0a197bcd5933c3e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_ip_protocol </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this stream to capture all packets with matching IP protocol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to. </td></tr>
    <tr><td class="paramname">protocol</td><td>The IP protocol to match against.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="gad3f858951323a44d4ce0525d58b6b442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_ip_source_host </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>shost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this stream to capture all packets with matching source hostname. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to. </td></tr>
    <tr><td class="paramname">shost</td><td>The source hostname to match against.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="ga3d7cf2e688403f3471166cc29e9cb496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_ip_source_hostport </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>shost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this stream to capture all packets with the matching protocol, source hostname and source port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to. </td></tr>
    <tr><td class="paramname">shost</td><td>The source hostname to match against. </td></tr>
    <tr><td class="paramname">sport</td><td>The source port to match against.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="ga0f158c98ef8c4a20e45814bfb1a1fde7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_ip_source_port </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this stream to capture all packets with matching source port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to. </td></tr>
    <tr><td class="paramname">sport</td><td>The source port to match against.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="gaa085b627b12075d9df4f6515e831b455"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_mismatch </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this stream to capture all packets that haven't been caught by another stream and are not requested by the kernel network stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 on success, a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="ga42cd4eec7735d8ce35ecec8d86dee695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_reset </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all stream filters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to remove the filters from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3bd0ac0a3c54818e422378be2ab9419e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_stream_set_str </td>
          <td>(</td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the stream to capture all packets matching the specified filter string. This is the preferred way of adding filters to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to send the packets to. </td></tr>
    <tr><td class="paramname">str</td><td>The filter to match against. Filters are constructed as a comma separated list of key-value pairs, except for the special cases "all", "mismatch", "ip", "tcp", and "udp". Available keywords are:</td></tr>
  </table>
  </dd>
</dl>
<table class="doxtable">
<tr>
<th>key-value pair </th><th>Description  </th></tr>
<tr>
<td>dmac=xx:xx:xx:xx:xx:xx </td><td>Filter on destination MAC address. </td></tr>
<tr>
<td>smac=xx:xx:xx:xx:xx:xx </td><td>Filter on source MAC addres. </td></tr>
<tr>
<td>vid=INT </td><td>Filter on VLAN id number. </td></tr>
<tr>
<td>eth_type=ip|INT </td><td>Filter on the ethernet type number (see net/ethertype.h header). </td></tr>
<tr>
<td>shost=hostname </td><td>Filter on source hostname, hostname can be either an IP address or a resolvable string. </td></tr>
<tr>
<td>dhost=hostname </td><td>Filter on destination hostname, hostname can be either an IP address or a resolvable string. </td></tr>
<tr>
<td>ip_protocol=udp|tcp|INT </td><td>Filter on ip protocol (set netinet/in.h header). </td></tr>
<tr>
<td>sport=INT </td><td>Filter on source port. </td></tr>
<tr>
<td>dport=INT </td><td>Filter on destination port. </td></tr>
<tr>
<td>all </td><td>All packets to this stream that haven't been filtered by another stream. </td></tr>
<tr>
<td>mismatch </td><td>All packets to this stream that haven't been filtered by another stream and are not requested by the kernel network stack. </td></tr>
<tr>
<td>ip </td><td>Shorthand for eth_type=ip. </td></tr>
<tr>
<td>tcp </td><td>Shorthand for ip_protocol=tcp. </td></tr>
<tr>
<td>udp </td><td>Shorthand for ip_protocol=udp. </td></tr>
</table>
<p>This function will return 0 on success or a negative number on failure. </p>

</div>
</div>
<a class="anchor" id="ga70a0155a66123cff377d48e4d63bbe28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_thread_alloc </td>
          <td>(</td>
          <td class="paramtype">struct sc_thread **&#160;</td>
          <td class="paramname"><em>thread_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_session *&#160;</td>
          <td class="paramname"><em>scs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a SolarCapture thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_out</td><td>The allocated thread object is returned here </td></tr>
    <tr><td class="paramname">attr</td><td>Attributes </td></tr>
    <tr><td class="paramname">scs</td><td>The session</td></tr>
  </table>
  </dd>
</dl>
<p>This function allocates a SolarCapture thread.</p>
<p>Normally SolarCapture creates an OS thread for the sc_thread object, and starts the thread when <a class="el" href="group__scapi.html#ga7ce051535aeecdd0d0c5dc29e3ff4ed4" title="Start a SolarCapture session. ">sc_session_go()</a> is called. If the 'managed' attribute is set to false, then it is up to the application to create an underlying thread. </p>

</div>
</div>
<a class="anchor" id="ga8c7b6a546594c50502c5727916b0f1dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_thread_calloc </td>
          <td>(</td>
          <td class="paramtype">struct sc_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory to be used by a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread </td></tr>
    <tr><td class="paramname">bytes</td><td>Size of memory area to allocate</td></tr>
  </table>
  </dd>
</dl>
<p>This function is intended to be used for allocating small amounts of memory that are used on performance critical paths, such as the private state used by the implementation of a node.</p>
<p>The memory region may overlap cache lines used by other allocations from this API for the same <code>thread</code>. </p>

</div>
</div>
<a class="anchor" id="ga3fc4a1b23bc0ef3c6289f3e6a6069384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_thread_calloc_aligned </td>
          <td>(</td>
          <td class="paramtype">struct sc_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory to be used by a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread </td></tr>
    <tr><td class="paramname">bytes</td><td>Size of memory area wanted </td></tr>
    <tr><td class="paramname">align</td><td>Alignment of memory area wanted</td></tr>
  </table>
  </dd>
</dl>
<p>This function is intended to be used for allocating small amounts of memory that are used on performance critical paths, such as the private state used by the implementation of a node.</p>
<p>The memory region may overlap cache lines used by other allocations from this API for the same <code>thread</code>. </p>

</div>
</div>
<a class="anchor" id="ga47edbb02fa9f4c20ea621c4d1889ef52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_thread_get_time </td>
          <td>(</td>
          <td class="paramtype">const struct sc_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>time_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a thread's "current time". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread </td></tr>
    <tr><td class="paramname">time_out</td><td>The current time is returned here</td></tr>
  </table>
  </dd>
</dl>
<p>Each thread's current time is updated by the polling loop, so may or may not be up-to-date when you call this function. The clock used as the time base is CLOCK_REALTIME. </p>

</div>
</div>
<a class="anchor" id="ga1fd26dc0e2b9363480ff1a25b9138787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_thread_mfree </td>
          <td>(</td>
          <td class="paramtype">struct sc_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread </td></tr>
    <tr><td class="paramname">mem</td><td>The memory area</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to free memory allocated with <a class="el" href="group__scapi.html#ga8c7b6a546594c50502c5727916b0f1dd" title="Allocate memory to be used by a thread. ">sc_thread_calloc</a> or <a class="el" href="group__scapi.html#ga3fc4a1b23bc0ef3c6289f3e6a6069384" title="Allocate memory to be used by a thread. ">sc_thread_calloc_aligned</a>. </p>

</div>
</div>
<a class="anchor" id="ga5c65e8c246b8379a0b688d7e535eeb63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_thread_poll </td>
          <td>(</td>
          <td class="paramtype">struct sc_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to poll an unmanaged thread. This drives events through the node graph.</p>
<p>Note: For managed threads this functionality is provided internally by solar_capture.</p>
<p>The return value indicates whether any work was done. If the return is true, then one of the following has happened: Packets have been received by a VI; Packets have been received by a mailbox; Packets have been handled by a node; A timer has expired. </p>

</div>
</div>
<a class="anchor" id="ga13794a8b3ef6bce53ad9f5e00c0afa06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_timer_expire_after_ns </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>delta_ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a callback in the future. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>A callback object </td></tr>
    <tr><td class="paramname">delta_ns</td><td>How far in the future in nanoseconds.</td></tr>
  </table>
  </dd>
</dl>
<p>The callback will be invoked at or after the specified time delta in nanoseconds. If <code>delta_ns</code> is zero or negative then the handler function will be invoked as soon as possible. </p>

</div>
</div>
<a class="anchor" id="ga7b86d78ef588c9513e52f7eb6ca14370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_timer_expire_at </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a callback at a given time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>A callback object </td></tr>
    <tr><td class="paramname">time</td><td>Time at which callback is requested</td></tr>
  </table>
  </dd>
</dl>
<p>The callback <code>cb</code> will be invoked at or after the specified time. If the time is in the past, then the handler function will be invoked as soon as possible.</p>
<p>The time is relative to the system realtime clock (CLOCK_REALTIME), which is the same clock returned by <a class="el" href="group__scapi.html#ga47edbb02fa9f4c20ea621c4d1889ef52" title="Return a thread&#39;s &quot;current time&quot;. ">sc_thread_get_time()</a>. </p>

</div>
</div>
<a class="anchor" id="ga12fcd6ecf711f40c0d9fff65e8b3b6d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_timer_get_expiry_time </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>ts_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the expiry time of a timer callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>A callback object </td></tr>
    <tr><td class="paramname">ts_out</td><td>The expiry time is returned here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if <code>cb</code> is a timer else -1 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7722a172bf7b66915c3835367dd05580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_timer_push_back_ns </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__callback">sc_callback</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>delta_ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push the expiry time further into the future. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>A callback object </td></tr>
    <tr><td class="paramname">delta_ns</td><td>How far in the future in nanoseconds.</td></tr>
  </table>
  </dd>
</dl>
<p>This function pushes the expiry time of a timer callback further into the future.</p>
<p>The callback <code>cb</code> must either be a currently active timer registered with <a class="el" href="group__scapi.html#ga7b86d78ef588c9513e52f7eb6ca14370" title="Request a callback at a given time. ">sc_timer_expire_at()</a> or <a class="el" href="group__scapi.html#ga13794a8b3ef6bce53ad9f5e00c0afa06" title="Request a callback in the future. ">sc_timer_expire_after_ns()</a>, or it must be an inactive timer. ie. The most recent use of <code>cb</code> must have been as a timer callback.</p>
<p>If <code>cb</code> is active, then it is rescheduled at its current expiry time plus <code>delta_ns</code>. If it is not active then it is scheduled at its previous expiry time plus <code>delta_ns</code>. </p>

</div>
</div>
<a class="anchor" id="ga5b4f28a80824dc498d43b040e6c089e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_vi_add_stream </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__vi">sc_vi</a> *&#160;</td>
          <td class="paramname"><em>vi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct a packet stream to a VI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vi</td><td>The VI receiving packets </td></tr>
    <tr><td class="paramname">stream</td><td>The packet stream</td></tr>
  </table>
  </dd>
</dl>
<p>Arrange for the packet stream identified by <code>stream</code> to be copied or steered to <code>vi</code>. </p>

</div>
</div>
<a class="anchor" id="ga1843e2bb992926d68abf9098db8ac0a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_vi_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__vi">sc_vi</a> **&#160;</td>
          <td class="paramname"><em>vi_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a VI instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vi_out</td><td>The allocated VI is returned here </td></tr>
    <tr><td class="paramname">attr</td><td>Attributes </td></tr>
    <tr><td class="paramname">thread</td><td>The thread the VI will be in </td></tr>
    <tr><td class="paramname">interface</td><td>The network interface to receive packets from</td></tr>
  </table>
  </dd>
</dl>
<p>A VI is a "virtual network interface" and supports receiving packets from the network. Packets received by a VI are passed to nodes (<a class="el" href="group__scapi.html#structsc__node" title="Description of a node. ">sc_node</a>) for processing. </p>

</div>
</div>
<a class="anchor" id="gaa12972dbe919f4f6dae988c54d81dca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_vi_alloc_from_group </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__vi">sc_vi</a> **&#160;</td>
          <td class="paramname"><em>vi_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_vi_group *&#160;</td>
          <td class="paramname"><em>vi_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a VI instance from a VI group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vi_out</td><td>The allocated VI is returned here </td></tr>
    <tr><td class="paramname">attr</td><td>Attributes </td></tr>
    <tr><td class="paramname">thread</td><td>The thread the VI will be in </td></tr>
    <tr><td class="paramname">vi_group</td><td>The VI group</td></tr>
  </table>
  </dd>
</dl>
<p>See also <a class="el" href="group__scapi.html#ga9d24a4ec17529a249d8fda7084c3a4ab" title="Allocate a VI group. ">sc_vi_group_alloc()</a> and <a class="el" href="group__scapi.html#ga1843e2bb992926d68abf9098db8ac0a5" title="Allocate a VI instance. ">sc_vi_alloc()</a>. </p>

</div>
</div>
<a class="anchor" id="ga818e3afd422fbde9d86239cf167e73d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sc_vi_get_interface_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__vi">sc_vi</a> *&#160;</td>
          <td class="paramname"><em>vi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the network interface associated with a VI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vi</td><td>The VI</td></tr>
  </table>
  </dd>
</dl>
<p>This call returns the name of the network interface associated with the <a class="el" href="group__scapi.html#structsc__vi" title="A VI object. ">sc_vi</a> object. This can be different from the interface name used to create the <a class="el" href="group__scapi.html#structsc__vi" title="A VI object. ">sc_vi</a> when application clustering is used.</p>
<p>The network interface name is most often needed so that the application can create an injector on the same interface as a VI. </p>

</div>
</div>
<a class="anchor" id="ga331ad371d93a2070456e4dbbd2727b1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_thread* sc_vi_get_thread </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__vi">sc_vi</a> *&#160;</td>
          <td class="paramname"><em>vi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the thread associated with a VI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vi</td><td>The VI </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7cab35bb167da9f925e6e4bb312ca1ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_vi_group_add_stream </td>
          <td>(</td>
          <td class="paramtype">struct sc_vi_group *&#160;</td>
          <td class="paramname"><em>vi_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_stream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct a packet stream to a group of VIs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vi_group</td><td>The VI group receiving packets </td></tr>
    <tr><td class="paramname">stream</td><td>The packet stream</td></tr>
  </table>
  </dd>
</dl>
<p>Arrange for the packet stream identified by <code>stream</code> to be copied or steered to the VIs that comprise <code>vi_group</code>.</p>
<p>Note that packets are spread over the VIs in a group by computing a hash on the addresses in the packet headers. Normally the hash is computed over the IP addresses, and for TCP packets also the port numbers. The hash selects a VI within the group, so that packets with the same addresses are consistently delivered to the same VI.</p>
<p>If <code>stream</code> identifies a set of packets that all have the same source and destination IP addresses (and ports in the case of TCP) then they will all be received by a single VI. </p>

</div>
</div>
<a class="anchor" id="ga9d24a4ec17529a249d8fda7084c3a4ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_vi_group_alloc </td>
          <td>(</td>
          <td class="paramtype">struct sc_vi_group **&#160;</td>
          <td class="paramname"><em>vi_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__scapi.html#structsc__attr">sc_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sc_session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_vis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a VI group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vi_out</td><td>The allocated VI is returned here </td></tr>
    <tr><td class="paramname">attr</td><td>Attributes </td></tr>
    <tr><td class="paramname">session</td><td>The SolarCapture session </td></tr>
    <tr><td class="paramname">interface</td><td>The network interface to receive packets from </td></tr>
    <tr><td class="paramname">num_vis</td><td>The number of VIs in the group</td></tr>
  </table>
  </dd>
</dl>
<p>A VI group provides a way to distribute packet capture over multiple threads. A VI group consists of a set of VIs, each of which receives a distinct subset of the streams directed at the group.</p>
<p>Streams are directed to a group by calling <a class="el" href="group__scapi.html#ga7cab35bb167da9f925e6e4bb312ca1ed" title="Direct a packet stream to a group of VIs. ">sc_vi_group_add_stream()</a>.</p>
<p>While a VI allocated from a group receives packets from streams directed to the group (<a class="el" href="group__scapi.html#ga7cab35bb167da9f925e6e4bb312ca1ed" title="Direct a packet stream to a group of VIs. ">sc_vi_group_add_stream()</a>), it is also possible to use <a class="el" href="group__scapi.html#ga5b4f28a80824dc498d43b040e6c089e5" title="Direct a packet stream to a VI. ">sc_vi_add_stream()</a> to direct a specific stream to a specific member of the group. </p>

</div>
</div>
<a class="anchor" id="ga82c65ba3781ef9d4333806bbd54a2eb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_session* sc_vi_group_get_session </td>
          <td>(</td>
          <td class="paramtype">const struct sc_vi_group *&#160;</td>
          <td class="paramname"><em>vi_group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the session associated with a VI group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vi_group</td><td>The VI group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa2a9c5b65648bc1c09016f1fdfda57ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_vi_set_recv_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__vi">sc_vi</a> *&#160;</td>
          <td class="paramname"><em>vi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__scapi.html#structsc__node">sc_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the node a VI should deliver its received packets to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vi</td><td>The VI receiving packets </td></tr>
    <tr><td class="paramname">node</td><td>The node to deliver packets to </td></tr>
    <tr><td class="paramname">name_opt</td><td>Optional ingress port name (may be NULL)</td></tr>
  </table>
  </dd>
</dl>
<p>Since SolarCapture 1.1, if <code>node</code> is in a different thread from <code>vi</code>, then this function automatically creates a link between the threads using mailboxes. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 10 2015 14:39:30 for SolarCapture C Bindings by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
