<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SolarCapture C Bindings: SolarCapture Nodes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="sf_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SolarCapture C Bindings
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">SolarCapture Nodes</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structsc__arista__ts__node"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scnode.html#structsc__arista__ts__node">sc_arista_ts_node</a></td></tr>
<tr class="memdesc:structsc__arista__ts__node"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node is to be used with Arista switches that are able to add hardware timestamps to packets. This is useful when SolarCapture is doing software timestamping, as it provides more precise timestamps.  <a href="group__scnode.html#structsc__arista__ts__node">More...</a><br/></td></tr>
<tr class="separator:structsc__arista__ts__node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__batch__limiter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scnode.html#structsc__batch__limiter">sc_batch_limiter</a></td></tr>
<tr class="memdesc:structsc__batch__limiter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node to limit the maximum batch size sent to downstream nodes.  <a href="group__scnode.html#structsc__batch__limiter">More...</a><br/></td></tr>
<tr class="separator:structsc__batch__limiter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__delay__line"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scnode.html#structsc__delay__line">sc_delay_line</a></td></tr>
<tr class="memdesc:structsc__delay__line"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node to delay upstream packets by a random time within a given time range. Randomness is achieved by performing a hash on the destination IP address and can be controlled using the <code>num_lines</code> argument.  <a href="group__scnode.html#structsc__delay__line">More...</a><br/></td></tr>
<tr class="separator:structsc__delay__line"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__filter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scnode.html#structsc__filter">sc_filter</a></td></tr>
<tr class="memdesc:structsc__filter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node to direct all matched packets to one output and all other packets to another output. The filter can be provided via a BPF string, or via a <a class="el" href="group__scapi.html#structsc__pkt__predicate" title="A packet predicate object. ">sc_pkt_predicate</a> object.  <a href="group__scnode.html#structsc__filter">More...</a><br/></td></tr>
<tr class="separator:structsc__filter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__reader"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scnode.html#structsc__reader">sc_reader</a></td></tr>
<tr class="memdesc:structsc__reader"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an input stream of data in PCAP format and outputs individual packets.  <a href="group__scnode.html#structsc__reader">More...</a><br/></td></tr>
<tr class="separator:structsc__reader"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsc__tap"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scnode.html#structsc__tap">sc_tap</a></td></tr>
<tr class="memdesc:structsc__tap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward input to output and a copy of input to the 'tap' output. If a BPF or predicate filter is specified, only packets matching the filter are duplicated to the 'tap' output.  <a href="group__scnode.html#structsc__tap">More...</a><br/></td></tr>
<tr class="separator:structsc__tap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structsc__arista__ts__node" id="structsc__arista__ts__node"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_arista_ts_node</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This node is to be used with Arista switches that are able to add hardware timestamps to packets. This is useful when SolarCapture is doing software timestamping, as it provides more precise timestamps. </p>
<h3>Arguments:</h3>
<table class="doxtable">
<tr>
<th>Argument </th><th>Optional? </th><th>Default </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>kf_ip_proto </td><td>Yes </td><td>253 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>The IP protocol used to send key frames. </td></tr>
<tr>
<td>log_level </td><td>Yes </td><td>"sync" </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> </td><td>The logging level of the node, must be set to one of "silent", "errors", "setup", "sync" or "verbose". </td></tr>
<tr>
<td>filter_oui </td><td>Yes </td><td></td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> </td><td>Filter out timestamps with this OUI. </td></tr>
<tr>
<td>kf_device </td><td>Yes </td><td></td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> </td><td>Filter keyframes by device field. </td></tr>
<tr>
<td>kf_eth_dhost </td><td>No </td><td></td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> </td><td>Destination MAC address for the keyframes. </td></tr>
<tr>
<td>kf_ip_dest </td><td>No </td><td></td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> </td><td>Destination IP address for the keyframes. </td></tr>
<tr>
<td>tick_freq </td><td>Yes </td><td>350000000 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>Expected frequency in Hz of the switch tick. </td></tr>
<tr>
<td>max_freq_error_ppm </td><td>Yes </td><td>20000 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>Max ppm between expected and observed frequency before entering no sync state. </td></tr>
<tr>
<td>lost_sync_ms </td><td>Yes </td><td>10000 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>Time after last keyframe to enter lost sync state. </td></tr>
<tr>
<td>no_sync_ms </td><td>Yes </td><td>60000 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>Time after last keyframe to enter no sync state. </td></tr>
<tr>
<td>no_sync_drop </td><td>Yes </td><td>0 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>Toggle sync drop, set to 1 for on 0 for off. </td></tr>
<tr>
<td>strip_ticks </td><td>Yes </td><td>1 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>Toggle the option for the node to strip switch timestamps. Set to 0 for off and 1 for on. </td></tr>
</table>
<h3>Named Input Links:</h3>
<p>None</p>
<h3>Output Links:</h3>
<table class="doxtable">
<tr>
<th>Link </th><th>Description  </th></tr>
<tr>
<td>"" </td><td>All packets that have not been filtered by the node are sent down this link. </td></tr>
</table>
<h3>Exposed Statistics:</h3>
<table class="doxtable">
<tr>
<th>Name </th><th>Type </th><th>Data Type </th><th>Description  </th></tr>
<tr>
<td>max_host_t_delta </td><td>double </td><td>config </td><td>Max delta in seconds the node can compute a tick-delta over. </td></tr>
<tr>
<td>max_freq_error </td><td>double </td><td>config </td><td>Max ppm allowed between measured and expected tick frequency before entering no sync state. </td></tr>
<tr>
<td>lost_sync_ms </td><td>int </td><td>config </td><td>Time in milliseconds spent in lost sync state. </td></tr>
<tr>
<td>no_sync_ms </td><td>int </td><td>config </td><td>Time in milliseconds spent in no sync state. </td></tr>
<tr>
<td>exp_tick_freq </td><td>int </td><td>config </td><td>The expected tick frequency in Hz. </td></tr>
<tr>
<td>strip_ticks </td><td>int </td><td>config </td><td>1 if the node is stripping ticks 0 otherwise. </td></tr>
<tr>
<td>log_level </td><td>int </td><td>config </td><td>The log level. </td></tr>
<tr>
<td>tick_freq </td><td>double </td><td>magnitude </td><td>The measured tick frequency in Hz. </td></tr>
<tr>
<td>n_keyframes </td><td>uint64_t </td><td>pkt_count </td><td>Number of keyframes processed by the node. </td></tr>
<tr>
<td>n_filtered_oui </td><td>uint64_t </td><td>pkt_count </td><td>Number of packets filtered out by OUI. </td></tr>
<tr>
<td>n_filtered_other </td><td>uint64_t </td><td>pkt_count </td><td>Number of packets filtered out for other reasons. </td></tr>
<tr>
<td>n_skew_zero_ticks </td><td>uint64_t </td><td>pkt_count </td><td>Number of skew zero packets received. </td></tr>
<tr>
<td>n_lost_sync </td><td>uint64_t </td><td>pkt_count </td><td>Number of packets processed whilst in lost sync state. </td></tr>
<tr>
<td>n_no_sync </td><td>uint64_t </td><td>pkt_count </td><td>Number of packets processed whilst in no sync state. </td></tr>
<tr>
<td>n_kf_len_mismatch </td><td>uint64_t </td><td>pkt_count </td><td>Number of packets received where the keyframe length did not match. </td></tr>
<tr>
<td>n_kf_dev_mismatch </td><td>uint64_t </td><td>pkt_count </td><td>Number of packets received where the device field did not match. </td></tr>
<tr>
<td>n_kf_bad_fcs_type </td><td>uint64_t </td><td>pkt_count </td><td>Number of keyframes with a bad FCS. </td></tr>
<tr>
<td>kf_switch_drops </td><td>uint64_t </td><td>pkt_count </td><td>Number of keyframes dropped by the switch. </td></tr>
<tr>
<td>n_kf_big_gap </td><td>uint64_t </td><td>pkt_count </td><td>Number of large gaps between keyframes. </td></tr>
<tr>
<td>n_skew </td><td>uint64_t </td><td>ev_count </td><td>Number of skews. </td></tr>
<tr>
<td>enter_no_sync </td><td>uint64_t </td><td>ev_count </td><td>Number of times the node has entered no sync state. </td></tr>
<tr>
<td>enter_sync1 </td><td>uint64_t </td><td>ev_count </td><td>Number of times the node has entered sync1 state. </td></tr>
<tr>
<td>enter_sync2 </td><td>uint64_t </td><td>ev_count </td><td>Number of times the node has entered sync2 state. </td></tr>
<tr>
<td>enter_lost_sync </td><td>uint64_t </td><td>ev_count </td><td>Number of times the node has entered lost sync state. </td></tr>
</table>
</div>
</div>
</div>
<a name="structsc__batch__limiter" id="structsc__batch__limiter"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_batch_limiter</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Node to limit the maximum batch size sent to downstream nodes. </p>
<p>This node can work in one of two modes</p>
<ul>
<li>default &ndash; Send packets as soon as possible.</li>
<li>on_idle &ndash; Only send packets when the node detects it is in an idle state.</li>
</ul>
<h3>Arguments:</h3>
<table class="doxtable">
<tr>
<th>Argument </th><th>Optional? </th><th>Default </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>max_packets </td><td>Yes </td><td>64 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>The maximum number of packets in a batch. </td></tr>
<tr>
<td>mode </td><td>Yes </td><td>NULL </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>Batching mode can be either NULL for default mode or "on_idle". </td></tr>
</table>
<h3>Named Input Links:</h3>
<p>None</p>
<h3>Output Links:</h3>
<table class="doxtable">
<tr>
<th>Link </th><th>Description  </th></tr>
<tr>
<td>"" </td><td>All packets are sent down this link. </td></tr>
</table>
</div>
</div>
</div>
<a name="structsc__delay__line" id="structsc__delay__line"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_delay_line</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Node to delay upstream packets by a random time within a given time range. Randomness is achieved by performing a hash on the destination IP address and can be controlled using the <code>num_lines</code> argument. </p>
<p>If <code>num_lines</code> = 1:</p>
<ul>
<li><code>usec/<code>nsec</code> must</code> be a single value.</li>
<li>All packets will be delayed by this amount.</li>
</ul>
<p>If <code>num_lines</code> &gt; 1:</p>
<ul>
<li><code>usec/<code>nsec</code> must</code> be a range of values &lt;min_delay&gt;-&lt;max_delay&gt;.</li>
<li>Non-IP packets are delayed by exactly &lt;min_delay&gt;.</li>
<li>IP packets are assigned a line by hashing the destination IP address.</li>
<li>For a given line in (0, ..., num_lines-1) the delay is &lt;min_delay&gt; + (&lt;max_delay&gt; - &lt;min_delay&gt;) * (line / num_lines)</li>
</ul>
<h3>Arguments:</h3>
<table class="doxtable">
<tr>
<th>Argument </th><th>Optional? </th><th>Default </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>num_lines </td><td>Yes </td><td>1 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>Number of lines used in the hash. </td></tr>
<tr>
<td>usec </td><td>Yes </td><td>NULL </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> </td><td>Set this to a string of the form "\&lt;min_delay\&gt;[-\&lt;max_delay\&gt;]" to set the delay time of the node in microseconds. </td></tr>
<tr>
<td>nsec </td><td>Yes </td><td>NULL </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> </td><td>Set this to a string of the form "\&lt;min_delay\&gt;[-\&lt;max_delay\&gt;]" to set the delay time of the node in nanoseconds. </td></tr>
</table>
<p>Note: One and only one of usec and nsec must be set.</p>
<h3>Named Input Links:</h3>
<p>None</p>
<h3>Output Links:</h3>
<table class="doxtable">
<tr>
<th>Link </th><th>Description  </th></tr>
<tr>
<td>"" </td><td>All packets are sent down this link. </td></tr>
</table>
</div>
</div>
</div>
<a name="structsc__filter" id="structsc__filter"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Node to direct all matched packets to one output and all other packets to another output. The filter can be provided via a BPF string, or via a <a class="el" href="group__scapi.html#structsc__pkt__predicate" title="A packet predicate object. ">sc_pkt_predicate</a> object. </p>
<h3>Arguments:</h3>
<table class="doxtable">
<tr>
<th>Argument </th><th>Optional? </th><th>Default </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>bpf </td><td>Yes </td><td>NULL </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> </td><td>Filter string in Berkeley Packet Filter format. </td></tr>
<tr>
<td>predicate </td><td>Yes </td><td>NULL </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a582ef31fdf6cc8bdbd1153cb2afc560b">SC_PARAM_OBJ</a> </td><td>An <a class="el" href="group__scapi.html#gga7dbec837a1592a9f6a4bc649ea583f0dae140bed569231d8aa0df5929f388cb03">SC_OBJ_PKT_PREDICATE</a> to use as a filter. </td></tr>
</table>
<p>Note: Exactly one of bpf and predicate must be set.</p>
<h3>Named Input Links:</h3>
<p>None</p>
<h3>Output Links:</h3>
<table class="doxtable">
<tr>
<th>Link </th><th>Description  </th></tr>
<tr>
<td>"" </td><td>Packets matched by the filter. </td></tr>
<tr>
<td>"not_matched" </td><td>Packets not matched by the filter. </td></tr>
</table>
</div>
</div>
</div>
<a name="structsc__reader" id="structsc__reader"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_reader</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Takes an input stream of data in PCAP format and outputs individual packets. </p>
<p>PCAP data can be sent to this node either by passing a filename or file descriptor, in which case the node will create a new ::sc_fd_reader node upstream, or by explicitly connecting a node that sends PCAP data.</p>
<p>Packets can be passed on to downstream nodes in one of three modes:</p>
<ul>
<li>none &ndash; Emit packets as they are read.</li>
<li>all-input &ndash; Emit packets when node receives end-of-stream. There will be a failure at runtime if the pool is too small to hold the entire input file.</li>
<li>all-buffers &ndash; Emit packets when the buffers are full or when the node receives end-of-stream.</li>
</ul>
<h3>Arguments:</h3>
<table class="doxtable">
<tr>
<th>Argument </th><th>Optional? </th><th>Default </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>prefill </td><td>Yes </td><td>"none" </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> </td><td>Mode used to read PCAP files, can be one of "none", "all-input" or "all-buffers". </td></tr>
<tr>
<td>signal_eof </td><td>Yes </td><td>1 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>Set to 1 to pass end-of-stream after emitting all packets. Otherwise set to 0 </td></tr>
<tr>
<td>filename </td><td>Yes </td><td>NULL </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> </td><td>If fd is not set this tells the node to create a ::sc_fd_reader node to read PCAP data from the given filename. If fd is set then this file is used for logging purposes only. </td></tr>
<tr>
<td>fd </td><td>Yes </td><td>-1 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>Setting this tells the node to create a ::sc_fd_reader node to read PCAP data from the given file descriptor. </td></tr>
</table>
<h3>Named Input Links:</h3>
<p>None</p>
<h3>Output Links:</h3>
<table class="doxtable">
<tr>
<th>Link </th><th>Description  </th></tr>
<tr>
<td>"" </td><td>The converted unpacked <a class="el" href="group__scapi.html#structsc__packet" title="Representation of a packet. ">sc_packet</a> stream. </td></tr>
<tr>
<td>"input" </td><td>The PCAP format stream. </td></tr>
</table>
</div>
</div>
</div>
<a name="structsc__tap" id="structsc__tap"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sc_tap</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Forward input to output and a copy of input to the 'tap' output. If a BPF or predicate filter is specified, only packets matching the filter are duplicated to the 'tap' output. </p>
<p>The node can be placed in one of two modes:</p>
<ul>
<li>default:<ul>
<li>Input packets are always forwarded to "" immediately.</li>
<li>If buffers are available, they are copied to "tap" immediately, otherwise they never go to tap.</li>
</ul>
</li>
<li>Reliable:<ul>
<li>If buffers are available, all packets are forwarded to "" and "tap" immediately.</li>
<li>If not, they are delayed until buffers are available and then forwarded to "" and "tap" at that point.</li>
</ul>
</li>
</ul>
<p>Note: In reliable mode this node can potentially create a backlog large enough to provoke drops in an upstream node or VI.</p>
<h3>Arguments:</h3>
<table class="doxtable">
<tr>
<th>Argument </th><th>Optional? </th><th>Default </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>snap </td><td>Yes </td><td>0 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>Copy at most n bytes of the duplicated frames, set to 0 to disable. </td></tr>
<tr>
<td>reliable </td><td>Yes </td><td>0 </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a5eb052715a1b750096cf54f0befdf8ab">SC_PARAM_INT</a> </td><td>Set to 1/0 to enable/disable reliable mode. </td></tr>
<tr>
<td>bpf </td><td>Yes </td><td>NULL </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003af3b6a01f8d30af8d69d17567fa187f80">SC_PARAM_STR</a> </td><td>Filter to select packets to duplicate in BPF format. </td></tr>
<tr>
<td>predicate </td><td>Yes </td><td>NULL </td><td><a class="el" href="group__scapi.html#gga0fbf06fdd6b6fea5987db9f1925a6003a582ef31fdf6cc8bdbd1153cb2afc560b">SC_PARAM_OBJ</a> </td><td>Predicate object to select packets to duplicate. </td></tr>
</table>
<p>Note: At most one of bpf and predicate may be specified.</p>
<h3>Named Input Links:</h3>
<p>None</p>
<h3>Output Links:</h3>
<table class="doxtable">
<tr>
<th>Link </th><th>Description  </th></tr>
<tr>
<td>"" </td><td>All packets are sent down this link. </td></tr>
<tr>
<td>"tap" </td><td>The copy of the input. </td></tr>
</table>
</div>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 10 2015 14:39:30 for SolarCapture C Bindings by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
